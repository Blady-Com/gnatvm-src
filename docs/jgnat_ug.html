<html lang="en">
<head>
<title>GNAT User's Guide Supplement for the JVM Platform</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNAT User's Guide Supplement for the JVM Platform">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<h1 class="settitle">GNAT User's Guide Supplement for the JVM Platform</h1>
<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#About-This-Guide">About This Guide</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dir">(dir)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<div class="node">
<a name="About-This-Guide"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Getting-Started-with-GNAT-for-the-JVM">Getting Started with GNAT for the JVM</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">About This Guide</h2>

<!-- =========================================================================== -->
<p class="noindent">This guide describes the features and the use of GNAT for the JVM, the Ada
development environment for the Java platform. This guide also explains
how to use the Java API from Ada and how to interface Ada and the Java
programming language.

   <p>Before reading this manual you should be familiar with the <cite>GNAT
User Guide</cite> as a thorough understanding of the concepts and notions
explained there is needed to use GNAT effectively.

<ul class="menu">
<li><a accesskey="1" href="#What-This-Guide-Contains">What This Guide Contains</a>
<li><a accesskey="2" href="#What-you-should-know-before-reading-this-guide">What you should know before reading this guide</a>
<li><a accesskey="3" href="#Related-Information">Related Information</a>
<li><a accesskey="4" href="#Conventions">Conventions</a>
</ul>

<div class="node">
<a name="What-This-Guide-Contains"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-you-should-know-before-reading-this-guide">What you should know before reading this guide</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#About-This-Guide">About This Guide</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#About-This-Guide">About This Guide</a>

</div>

<h3 class="unnumberedsec">What This Guide Contains</h3>

<!--  -->
<p class="noindent">This guide contains the following chapters:

     <ul>
<li><a href="#Getting-Started-with-GNAT-for-the-JVM">Getting Started with GNAT for the JVM</a>, gives an overview of GNAT and its
tools and explains how to compile and run your first Ada program for the
Java platform.

     <li><a href="#Ada-_0026-Java-Interoperability">Ada &amp; Java Interoperability</a> explains how the Java API and the
services of any JVM class can be used from Ada. This section also explains
how Ada services can be exported to Java programmers.

     <li><a href="#Viewing-Class-Files-with-jvmlist">Viewing Class Files with jvmlist</a>, describes <code>jvmlist</code>, a
utility to disassemble a JVM <code>.class</code> file to view its contents:
bytecode, contant pool (i.e. symbol table), debugging info, etc. This
utility can also embed the original source code into the assembly listing.

     <li><a href="#Stripping-Debug-Info-with-jvmstrip">Stripping Debug Info with jvmstrip</a>, describes <code>jvmstrip</code> a
utility that strips a <code>.class</code> file, removing all of its debugging
info to reduce the file size.

     <li><a href="#Building-Archives-with-jarmake">Building Archives with jarmake</a>, describes the <code>jarmake</code> tool to
make a single <samp><span class="file">.jar</span></samp> file for an application built with GNAT. This is
useful when you want to ship a self-contained application built with GNAT
to someone who does not have GNAT installed. This tool is very useful
useful when creating "gnapplets" (GNAT applets, see <a href="#Creating-Gnapplets-with-GNAT">Creating Gnapplets with GNAT</a>).

     <li><a href="#Using-the-Java-API-with-jvm2ada">Using the Java API with jvm2ada</a>, describes the <code>jvm2ada</code>
interfacing tool that takes any JVM <samp><span class="file">.class</span></samp>, <samp><span class="file">.zip</span></samp> or
<samp><span class="file">.jar</span></samp> files as input and generates Ada package specs as output. The
resulting Ada specs can be used by Ada programs to interface to Java.

     <li><a href="#Java_002dSpecific-Pragmas">Java-Specific Pragmas</a> explains some special pragmas that have been
introduced to support certain aspects of interfacing between Ada and Java.

     <li><a href="#Mapping-Java-into-Ada">Mapping Java into Ada</a> gives details on how the Java API and, in
general, any Java class spec is mapped into an Ada package specification by
the <code>jvm2ada</code> tool.

     <li><a href="#Creating-Gnapplets-with-GNAT">Creating Gnapplets with GNAT</a>, explains how you can create
&ldquo;gnapplets&rdquo; (GNAT applets).

     <li><a href="#Debugging-Ada-Programs">Debugging Ada Programs</a>, describes how to run and
debug Ada programs.

     <li><a href="#Limitations">Limitations</a>, describes the language constructs, libraries and switches
that are not supported by GNAT for the JVM. 
</ul>

<div class="node">
<a name="What-you-should-know-before-reading-this-guide"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Related-Information">Related Information</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-This-Guide-Contains">What This Guide Contains</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#About-This-Guide">About This Guide</a>

</div>

<h3 class="unnumberedsec">What You Should Know Before Reading This Guide</h3>

<!--  -->
<p class="noindent">Before reading this document readers should be familiar with the
<cite>GNAT User Guide</cite> and have a conceptual understanding of the Java
technology.

<div class="node">
<a name="Related-Information"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Conventions">Conventions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-you-should-know-before-reading-this-guide">What you should know before reading this guide</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#About-This-Guide">About This Guide</a>

</div>

<h3 class="unnumberedsec">Related Information</h3>

<!--  -->
<p class="noindent">For further information about GNAT, Ada, and the Java technology,
we recommend consulting the following documents:

     <ul>
<li><cite>GNAT User Guide</cite>, contains introductory and reference material
for the GNAT development environemnt.

     <li><cite>Ada 2005 Language Reference Manual</cite>, contains all reference material
for the Ada programming language.

     <li><cite>The Java Tutorial: Object-Oriented Programming for the Internet</cite>,
2nd edition, by Mary Campione and Kathy Walrath, published by Addison
Wesley.

     <li><cite>The Java Virtual Machine Specification</cite>, by Tim Lindholm and Frank
Yellin, published by Addison Wesley. 
</ul>

<div class="node">
<a name="Conventions"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Related-Information">Related Information</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#About-This-Guide">About This Guide</a>

</div>

<h3 class="unnumberedsec">Conventions</h3>

<!--  -->
<p><a name="index-Conventions-1"></a><a name="index-Typographical-conventions-2"></a>
Following are examples of the typographical and graphic conventions used
in this guide:

     <ul>
<li><code>source code</code>, and <code>utility program names</code>.

     <li>&lsquo;<samp><span class="samp">Option flags</span></samp>&rsquo;.

     <li><samp><span class="file">File Names</span></samp>.

     <li><var>Variables</var>.

     <li><em>Emphasis</em>.

     <li>[optional information or parameters]

     <li>Examples are described by text
     <pre class="smallexample">          and then shown this way.
</pre>
     </ul>

<p class="noindent">Commands that are entered by the user are preceded in this manual by the
"<code>$ </code>" characters (dollar sign followed by space). If your system uses
this sequence as a prompt, then the commands will appear exactly as you see
them in the manual. If your system uses some other prompt, then the command
will appear with the <code>$</code> replaced by whatever prompt character you are
using.

<div class="node">
<a name="Getting-Started-with-GNAT-for-the-JVM"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ada-_0026-Java-Interoperability">Ada &amp; Java Interoperability</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#About-This-Guide">About This Guide</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="chapter">1 Getting Started with GNAT for the JVM</h2>

<!-- =========================================================================== -->
<ul class="menu">
<li><a accesskey="1" href="#Overview">Overview</a>
<li><a accesskey="2" href="#GNAT-Tools">GNAT Tools</a>
<li><a accesskey="3" href="#Java-Development-Kits-that-you-can-use-with-GNAT">Java Development Kits that you can use with GNAT</a>
<li><a accesskey="4" href="#Compiling-Your-First-Application-with-GNAT-for-the-JVM">Compiling Your First Application with GNAT for the JVM</a>
</ul>

<div class="node">
<a name="Overview"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#GNAT-Tools">GNAT Tools</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Getting-Started-with-GNAT-for-the-JVM">Getting Started with GNAT for the JVM</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Getting-Started-with-GNAT-for-the-JVM">Getting Started with GNAT for the JVM</a>

</div>

<h3 class="section">1.1 Overview</h3>

<!--  -->
<p class="noindent">The Java(TM) technology, introduced by Sun Microsystems, is a paradigm
whose goal is to add platform-independent programming flexibility to
Internet, Intranet and Extranet applications, embedded devices such as
Internet appliances, consumer electronics, smart cards, etc.

   <p>The Java technology comprises, a simple object-oriented programming
language (Java), a comprehensive set of libraries (Java API), and
a virtual machine (JVM) offering the same object code interface on
all platforms (bytecode).

   <p>Although the Java environment comes with a default programming language,
this language is not a fundamental component of the technology. Any
programming language that can be mapped onto the JVM can be used to
develop Java applications.

   <p>The GNAT system offers an Ada 2005 programming environment for
the Java platform. In addition to a bytecode compiler, binder and
linker, GNAT comprises a Java-to-Ada binding generator which produces
the Ada 2005 specs of the services contained in any Java <samp><span class="file">.class</span></samp>
file or API.  In addition to all of the conventional GNAT tools, a
bytecode disassembler and a <samp><span class="file">.class</span></samp> file stripper are also
provided with GNAT for the JVM.

   <p>Furthermore, because the <samp><span class="file">.class</span></samp> files generated by the GNAT
compiler are fully compliant with Sun's standard, the user can employ
any JVM to run Ada applications, any JVM debugger to debug Ada
code, and can use any of the Java tools that operate on <samp><span class="file">.class</span></samp>
files (e.g. <code>jar</code>, <code>javap</code>, etc.).

   <p>As a side note, the GNAT system is implemented in Ada and its sources
are available under the GPL.

<div class="node">
<a name="GNAT-Tools"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Java-Development-Kits-that-you-can-use-with-GNAT">Java Development Kits that you can use with GNAT</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Overview">Overview</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Getting-Started-with-GNAT-for-the-JVM">Getting Started with GNAT for the JVM</a>

</div>

<h3 class="section">1.2 GNAT Tools</h3>

<!--  -->
<p class="noindent">Most tools are regular GNAT tools that have been slightly adapted
for use with GNAT for the JVM. They are used in the same fashion as their
corresponding GNAT equivalent. These tools are:

     <ul>
<li><code>jvm-gnatcompile</code>: the compiler, compiles an Ada unit into one or more JVM
<samp><span class="file">.class</span></samp> files.

     <li><code>jvm-gnatbind</code>: the binder, generates an Ada source file
containing the elaboration code for the Ada application to run.

     <li><code>jvm-gnatlink</code>: the linker, compiles the source file generated
by <code>jvm-gnatbind</code>. <code>jvm-gnatlink</code> provides no linking capabilities
since the linker is directly embedded into the JVM.  To gather the
<samp><span class="file">.class</span></samp> files of an application into a single file, one can use
the <code>zip</code> or <code>jar</code> commands provided with your Java Development
Kit.

     <li><code>jvm-gnatmake</code>: the automatic make program, automatically
determines the set of sources needed by an Ada compilation unit, and
executes the necessary compilations, binding, and link.

     <li><code>jvm-gnatls</code>: the library browser, displays information about
compiled units, including dependences on the corresponding sources
files, and consistency of compilations.

     <li><code>jvm-gnatfind</code>: the find utility, provides an easy way to locate
the declaration and references for an Ada entity.

     <li><code>jvm-gnatxref</code>: the cross-referencer, allows you to generate a
full report of all cross-references in a given set of Ada units.

   </ul>

<p class="noindent">The GNAT tools which have been specifically developed for the JVM are:

     <ul>
<li><code>jvmlist</code>: The GNAT disassembler, (see <a href="#Viewing-Class-Files-with-jvmlist">Viewing Class Files with jvmlist</a>) disassembles a JVM <code>.class</code> file to view its contents:
bytecode, constant pool (i.e., symbol table), debugging info, etc. This
utility will also embed the original source code into the assembly listing. 
This utility is independent of the original programming language and works
equally well on programs containing a mixture of Ada and Java code.

     <li><code>jvmstrip</code>: The GNAT strip utility, (see <a href="#Stripping-Debug-Info-with-jvmstrip">Stripping Debug Info with jvmstrip</a>) is a utility that strips a <code>.class</code> file, removing all
of its debugging info to reduce file size. This tool is also
programming-language independent.

     <li><code>jarmake</code>: The GNAT archiver tool, (see <a href="#Building-Archives-with-jarmake">Building Archives with jarmake</a>) takes <samp><span class="file">.class</span></samp> files as input and recursively collects into
an uncompressed zip archive all the <samp><span class="file">.class</span></samp> files needed by the
<samp><span class="file">.class</span></samp> files specified on the command line. This tool can be used to
prepare self-standing applications or gnapplets that you can ship.  This
tool is programming-language independent.

     <li><code>jvm2ada</code>: The GNAT interfacing tool, (see <a href="#Using-the-Java-API-with-jvm2ada">Using the Java API with jvm2ada</a>) takes <samp><span class="file">.class</span></samp> files, or zip archives as input and generates
Ada package specifications as output. The resulting Ada package specs can be
<code>with</code>-ed by Ada programs to interface to Java services. 
</ul>

<div class="node">
<a name="Java-Development-Kits-that-you-can-use-with-GNAT"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Compiling-Your-First-Application-with-GNAT-for-the-JVM">Compiling Your First Application with GNAT for the JVM</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#GNAT-Tools">GNAT Tools</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Getting-Started-with-GNAT-for-the-JVM">Getting Started with GNAT for the JVM</a>

</div>

<h3 class="section">1.3 Java Development Kits that you can use with GNAT</h3>

<!--  -->
<p class="noindent">Because GNAT generates class files that are fully compliant with Sun's JVM
standard, you can use any Java Virtual Machine and bytecode tools that meet
the Sun Java platform standard.

<div class="node">
<a name="Compiling-Your-First-Application-with-GNAT-for-the-JVM"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Java-Development-Kits-that-you-can-use-with-GNAT">Java Development Kits that you can use with GNAT</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Getting-Started-with-GNAT-for-the-JVM">Getting Started with GNAT for the JVM</a>

</div>

<h3 class="section">1.4 Compiling Your First Application with GNAT</h3>

<!--  -->
<p class="noindent">To compile the following &ldquo;<code>Hello GNAT for the JVM</code>&rdquo; program put the
following in file <samp><span class="file">hello.adb</span></samp>:

<pre class="smallexample">     with Ada.Text_IO; use Ada.Text_IO;
     procedure Hello is
     begin
        Put_Line ("Hello GNAT for the JVM.");
     end Hello;
</pre>
   <p class="noindent">then type:

<pre class="smallexample">     $ jvm-gnatmake hello
</pre>
   <p class="noindent">This command will generate file <samp><span class="file">hello.class</span></samp>. To run it,
assuming you are using Sun's JDK (Java Development Kit), you can
just type

<pre class="smallexample">     $ java hello
</pre>
   <p class="noindent">It's as simple as that. To compile more complex Ada applications use
<code>jvm-gnatmake</code> as usual. If you want to use the GNAT compiler, binder,
and linker separately, you will need to individually invoke the appropriate
<code>jvm-gnatcompile</code>, <code>jvm-gnatbind</code> and <code>jvm-gnatlink</code> commands.

<div class="node">
<a name="Ada-%26-Java-Interoperability"></a>
<a name="Ada-_0026-Java-Interoperability"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Viewing-Class-Files-with-jvmlist">Viewing Class Files with jvmlist</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Getting-Started-with-GNAT-for-the-JVM">Getting Started with GNAT for the JVM</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="chapter">2 Ada &amp; Java Interoperability</h2>

<!-- =========================================================================== -->
<p class="noindent">One aspect of Java that makes it an interesting platform is its growing
set of API classes. It is therefore fundamental that the API be made
available to the Ada programmer transparently. It is also important that
the Ada programmer be able to write libraries or APIs for the Java platform
in Ada, and that these libraries be easily usable in any Java application. 
GNAT guarantees full interoperability between Ada and Java.

   <p>To achieve this goal, constructs that can appear in a Java class at the
specification level are mapped to Ada either by means of a corresponding
Ada feature or by using an implementation-defined Ada pragma.

   <p>In addition we have taken great care that the mapping from Java to Ada is
completely automatic. This means that GNAT comes with no Ada bindings
for the Java API, but instead provides a tool (see <a href="#Using-the-Java-API-with-jvm2ada">Using the Java API with jvm2ada</a>) which is able to produce Ada specifications from any set
of JVM <samp><span class="file">.class</span></samp> files.

<ul class="menu">
<li><a accesskey="1" href="#Importing-Java-Services-to-Ada">Importing Java Services to Ada</a>
<li><a accesskey="2" href="#Exporting-Ada-Services-to-Java">Exporting Ada Services to Java</a>
</ul>

<div class="node">
<a name="Importing-Java-Services-to-Ada"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Exporting-Ada-Services-to-Java">Exporting Ada Services to Java</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ada-_0026-Java-Interoperability">Ada &amp; Java Interoperability</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ada-_0026-Java-Interoperability">Ada &amp; Java Interoperability</a>

</div>

<h3 class="section">2.1 Importing Java Services to Ada</h3>

<!--  -->
<p class="noindent">To access the services provided by the Java API or by any set of
JVM <samp><span class="file">.class</span></samp> files, you should proceed as follows:

     <ol type=1 start=1>
<li>If your Java code is in source form, compile it using any Java compiler.

     <li>If you just want to import a variable or a subprogram from a Java class
use <code>pragma Import</code> (see <a href="#Pragma-Import-Java">Pragma Import Java</a>) in the Ada code
where you want to import the Java service.

     <li>More generally, you can use the <code>jvm2ada</code> utility to produce the Ada
specs (containing the appropriate Java-specific pragmas) for the <samp><span class="file">.class</span></samp>,
<samp><span class="file">.zip</span></samp>, or <samp><span class="file">.jar</span></samp> files containing the Java services you would
like to use from Ada (see <a href="#Using-the-Java-API-with-jvm2ada">Using the Java API with jvm2ada</a>). Note that
<code>jvm2ada</code> preserves, in the generated Ada specs, the names of the
original Java services (for a detailed explanation of the Java to Ada
mapping see <a href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>).

     <li><code>with</code> the needed Ada specs and use their services as usual.
        </ol>

<p class="noindent">It's as simple as that.

<div class="node">
<a name="Exporting-Ada-Services-to-Java"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Importing-Java-Services-to-Ada">Importing Java Services to Ada</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ada-_0026-Java-Interoperability">Ada &amp; Java Interoperability</a>

</div>

<h3 class="section">2.2 Exporting Ada Services to Java</h3>

<!--  -->
<p class="noindent">To export a set of Ada services to Java you should:

     <ol type=1 start=1>
<li>Use <code>pragma Export</code> and other Java interfacing pragmas inside the Ada
code (see <a href="#Java_002dSpecific-Pragmas">Java-Specific Pragmas</a>). This gives you complete control of
what is being generated and allows you to decide very precisely what the
exported services look like on the Java side.

     <li>Compile your Ada code with the GNAT compiler.

     <li>Use <code>javap</code> to display the spec of the <samp><span class="file">.class</span></samp> files generated
by GNAT whose services you would like to use in your Java code.
        </ol>

<div class="node">
<a name="Viewing-Class-Files-with-jvmlist"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Stripping-Debug-Info-with-jvmstrip">Stripping Debug Info with jvmstrip</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ada-_0026-Java-Interoperability">Ada &amp; Java Interoperability</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="chapter">3 Viewing Class Files with <code>jvmlist</code></h2>

<!-- =========================================================================== -->
<p><a name="index-jvmlist-3"></a>
The <code>jvmlist</code> tool takes JVM <samp><span class="file">.class</span></samp> files as input (directly or
regrouped in an uncompressed <samp><span class="file">.zip</span></samp> or <samp><span class="file">.jar</span></samp> file) and
disassembles it to view its contents: bytecode, constant pool (i.e., symbol
table), debugging info, etc. This utility can also embed the original source
code in the assembly listing.  <code>jvmlist</code> is independent of the original
programming language and works equally well on programs containing a mixture
of Ada and Java code.

<ul class="menu">
<li><a accesskey="1" href="#Running-jvmlist">Running jvmlist</a>
<li><a accesskey="2" href="#Switches-for-jvmlist">Switches for jvmlist</a>
</ul>

<div class="node">
<a name="Running-jvmlist"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Switches-for-jvmlist">Switches for jvmlist</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Viewing-Class-Files-with-jvmlist">Viewing Class Files with jvmlist</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Viewing-Class-Files-with-jvmlist">Viewing Class Files with jvmlist</a>

</div>

<h3 class="section">3.1 Running jvmlist</h3>

<!--  -->
<p class="noindent">The form of the <code>jvmlist</code> command is

<pre class="smallexample">     jvmlist [<var>switches</var>] <var>file</var> [<var>file</var> ... <var>file</var>]
</pre>
   <p class="noindent">where <var>file</var> can be one of the following:

     <ul>
<li>the name of a <samp><span class="file">.class</span></samp> file (possibly without the <samp><span class="file">.class</span></samp> suffix);

     <li>the name of an uncompressed zip archive (in this case the <code>jvmlist</code>
command applies to all <samp><span class="file">.class</span></samp> files within the archive);

     <li>the name of a <samp><span class="file">.class</span></samp> file within an uncompressed zip archive <br>
(e.g. <samp><span class="file">rt.jar/java/lang/Object.class</span></samp>). 
</ul>

<p class="noindent">File names can be prefixed with directory information.

   <p>The output of <code>jvmlist</code> contains a listing of all the fields and methods
declared inside the <samp><span class="file">.class</span></samp> file, in addition to various other class
information such as the class it extends, the interfaces it implements, etc.

   <p>If you select switch &lsquo;<samp><span class="samp">-c</span></samp>&rsquo;, then <code>jvmlist</code> will also print the
bytecode for each method. The bytecode mnemonics used by <code>jvmlist</code>
are the same as those documented in Sun's JVM book <i>The Java Virtual
Machine Specification</i> by Lindholm and Yellin. If you select switch &lsquo;<samp><span class="samp">-c</span></samp>&rsquo;,
<code>jvmlist</code> will also embed the original source code in the bytecode. 
For now, <code>jvmlist</code> only looks for source files in the current directory.

<div class="node">
<a name="Switches-for-jvmlist"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Running-jvmlist">Running jvmlist</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Viewing-Class-Files-with-jvmlist">Viewing Class Files with jvmlist</a>

</div>

<h3 class="section">3.2 Switches for jvmlist</h3>

<!--  -->
<p class="noindent">The following switches are available with the <code>jvmlist</code> utility:

     <dl>
<dt><code>-c</code><dd><a name="index-g_t_0040code_007b_002dc_007d-_0028_0040code_007bjvm2ada_007d_0029-4"></a>Display bytecode. By default <code>jvmlist</code> does not display the bytecode
of each method. This switch specifies that bytecode should be displayed.

     <br><dt><code>-g</code><dd><a name="index-g_t_0040code_007b_002dq_007d-_0028_0040code_007bjvm2ada_007d_0029-5"></a>Embed source code. This switch implies &lsquo;<samp><span class="samp">-c</span></samp>&rsquo; and embeds the original
source code within the disassembled bytecode. If the input <samp><span class="file">.class</span></samp>
file does not contain source file information, or if the source file cannot
be located in the current directory (the one where <code>jvmlist</code> was
invoked), then this switch is equivalent to &lsquo;<samp><span class="samp">-c</span></samp>&rsquo;.

     <br><dt><code>-l</code><dd><a name="index-g_t_0040code_007b_002dq_007d-_0028_0040code_007bjvm2ada_007d_0029-6"></a>Display line number tables.

     <br><dt><code>-p</code><dd><a name="index-g_t_0040code_007b_002dq_007d-_0028_0040code_007bjvm2ada_007d_0029-7"></a>Display the constant pool.

     <br><dt><code>-t</code><dd><a name="index-g_t_0040code_007b_002dq_007d-_0028_0040code_007bjvm2ada_007d_0029-8"></a>Display local variable tables.

     <br><dt><code>-v</code><dd><a name="index-g_t_0040code_007b_002dq_007d-_0028_0040code_007bjvm2ada_007d_0029-9"></a>Verbose. Outputs the name of each class file for which an Ada spec is
generated.

     <br><dt><code>-V</code><dd><a name="index-g_t_0040code_007b_002dq_007d-_0028_0040code_007bjvm2ada_007d_0029-10"></a>Very verbose. Implies -v. Each item that is encountered in a zip or jar
file is listed on the screen. Class files are preceded with a <code>-&gt;</code>,
other items are listed with a message saying that the item is skipped. 
Only class files whose name is listed twice (one preceded with a
<code>-&gt;</code> and the following one without the <code>-&gt;</code>) have a
corresponding Ada spec generated for them, other class files are ignored
(because for instance they are not public classes). 
</dl>

<div class="node">
<a name="Stripping-Debug-Info-with-jvmstrip"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Building-Archives-with-jarmake">Building Archives with jarmake</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Viewing-Class-Files-with-jvmlist">Viewing Class Files with jvmlist</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="chapter">4 Stripping Debug Info with <code>jvmstrip</code></h2>

<!-- ============================================================================ -->
<p><a name="index-jvmstrip-11"></a>
The <code>jvmstrip</code> tool takes a <samp><span class="file">.class</span></samp> files as input (directly or
packaged in an uncompressed <samp><span class="file">.zip</span></samp> or <samp><span class="file">.jar</span></samp> file) and strips
off all of its debugging info to reduce its size. This utility is independent
of the original programming language and works equally well on programs
containing a mixture of Ada and Java code.

<ul class="menu">
<li><a accesskey="1" href="#Running-jvmstrip">Running jvmstrip</a>
<li><a accesskey="2" href="#Switches-for-jvmstrip">Switches for jvmstrip</a>
</ul>

<div class="node">
<a name="Running-jvmstrip"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Switches-for-jvmstrip">Switches for jvmstrip</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Stripping-Debug-Info-with-jvmstrip">Stripping Debug Info with jvmstrip</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stripping-Debug-Info-with-jvmstrip">Stripping Debug Info with jvmstrip</a>

</div>

<h3 class="section">4.1 Running jvmstrip</h3>

<!--  -->
<p class="noindent">The form of the <code>jvmstrip</code> command is

<pre class="smallexample">     jvmstrip [<var>switches</var>] <var>file</var> [<var>file</var> ... <var>file</var>]
</pre>
   <p class="noindent">where <var>file</var> can be one of the following:

     <ul>
<li>the name of a <samp><span class="file">.class</span></samp> file

     <li>the name of an uncompressed zip archive (in this case the <code>jvmstrip</code>
command applies to all <samp><span class="file">.class</span></samp> files within the archive);
</ul>

<p class="noindent">File names can be prefixed with directory information.

   <p>The output of <code>jvmstrip</code> is a stripped <samp><span class="file">.class</span></samp> file which
replaces the original input file. If the input is an archive, then all of
the <samp><span class="file">.class</span></samp> files within the archive are stripped and the updated
archive replaces the input file.

<div class="node">
<a name="Switches-for-jvmstrip"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Running-jvmstrip">Running jvmstrip</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stripping-Debug-Info-with-jvmstrip">Stripping Debug Info with jvmstrip</a>

</div>

<h3 class="section">4.2 Switches for jvmstrip</h3>

<!--  -->
<p class="noindent">The following switches are available with the <code>jvmstrip</code> utility:

     <dl>
<dt><code>-v</code><dd><a name="index-g_t_0040code_007b_002dq_007d-_0028_0040code_007bjvm2ada_007d_0029-12"></a>Verbose. 
</dl>

<div class="node">
<a name="Building-Archives-with-jarmake"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-the-Java-API-with-jvm2ada">Using the Java API with jvm2ada</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Stripping-Debug-Info-with-jvmstrip">Stripping Debug Info with jvmstrip</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="chapter">5 Building Archives with <code>jarmake</code></h2>

<!-- =========================================================================== -->
<p><a name="index-jarmake-13"></a>
When building an Ada application with GNAT, a number of JVM <samp><span class="file">.class</span></samp>
files are generated. In addition to potentially being numerous, the
generated classes depend on the library <samp><span class="file">jgnat.jar</span></samp> which is
installed with GNAT.

   <p>If you need to ship your Ada application or gnapplet to people who do not
have GNAT installed this can be cumbersome as you would need to ship the
<samp><span class="file">.class</span></samp> files of your application along with <samp><span class="file">jgnat.jar</span></samp>.

   <p>To automate such process we have provided <code>jarmake</code>, the GNAT archiver
tool. <code>jarmake</code> takes <samp><span class="file">.class</span></samp> files as input and recursively
collects into an uncompressed zip archive all the <samp><span class="file">.class</span></samp> files needed
by the <samp><span class="file">.class</span></samp> files specified on the command line. This tool can be
used to prepare self-standing applications or gnapplets.

   <p>This utility is independent of the original programming language and works
equally well on programs containing a mixture of Ada and Java code.

<ul class="menu">
<li><a accesskey="1" href="#Running-jarmake">Running jarmake</a>
<li><a accesskey="2" href="#Switches-for-jarmake">Switches for jarmake</a>
</ul>

<div class="node">
<a name="Running-jarmake"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Switches-for-jarmake">Switches for jarmake</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Building-Archives-with-jarmake">Building Archives with jarmake</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Building-Archives-with-jarmake">Building Archives with jarmake</a>

</div>

<h3 class="section">5.1 Running jarmake</h3>

<!--  -->
<p class="noindent">The form of the <code>jarmake</code> command is

<pre class="smallexample">     jarmake [<var>switches</var>] <var>file</var> [<var>file</var> ... <var>file</var>]
</pre>
   <p class="noindent">where <var>file</var> can be one of the following:

     <ul>
<li>the name of a <samp><span class="file">.class</span></samp> file

     <li>the name of an image, sound or any other file that you want to bundle with
your application. 
</ul>

<p class="noindent">File names can be prefixed with directory information.

   <p>The output of <code>jarmake</code> is an uncompressed zip archive containing the
files specified on the command line along with the <samp><span class="file">.class</span></samp> files they
recursively reference.

<div class="node">
<a name="Switches-for-jarmake"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Running-jarmake">Running jarmake</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Building-Archives-with-jarmake">Building Archives with jarmake</a>

</div>

<h3 class="section">5.2 Switches for <code>jarmake</code></h3>

<!--  -->
<p class="noindent">The following switches are available with the <code>jarmake</code> utility:

     <dl>
<dt><code>-L</code><var>zip-archive</var><dd><a name="index-g_t_0040code_007b_002dL_007d-_0028_0040code_007bjarmake_007d_0029-14"></a>When searching for <samp><span class="file">.class</span></samp> files, look in the uncompressed zip archive
<var>zip-archive</var>.

     <br><dt><code>-j</code><dd><a name="index-g_t_0040code_007b_002dj_007d-_0028_0040code_007bjarmake_007d_0029-15"></a>Do not skip <samp><span class="file">.class</span></samp> files in the Java API. By default <code>jarmake</code>
skips all the <samp><span class="file">.class</span></samp> files in the Java API. By using this switch you
are asking <code>jarmake</code> to include Java API classes in the output zip
archive. If you set this flag you should also provide a <code>-L</code> flag
giving the location of the Java API zip archive.

     <br><dt><code>-k</code><dd><a name="index-g_t_0040code_007b_002dk_007d-_0028_0040code_007bjarmake_007d_0029-16"></a>Keep going even if not all of the <samp><span class="file">.class</span></samp> files are found. By default,
<code>jarmake</code> will stop if it cannot find all the needed <samp><span class="file">.class</span></samp>
files. By setting this switch <code>jarmake</code> will emit a warning message
when it cannot find a <samp><span class="file">.class</span></samp> file it is looking for and will continue.

     <br><dt><code>-m</code><dd><a name="index-g_t_0040code_007b_002dm_007d-_0028_0040code_007bjarmake_007d_0029-17"></a>Add a <code>Main-Class</code> attribute to the manifest for the first class encountered
that has a main method.

     <br><dt><code>-n</code><dd><a name="index-g_t_0040code_007b_002dn_007d-_0028_0040code_007bjarmake_007d_0029-18"></a>Do not include the <samp><span class="file">.class</span></samp> files of the library <samp><span class="file">jgnat.jar</span></samp>
in the output archive. By default these files are included in the output
archive so that the the archive is autonomous.

     <br><dt><code>-o </code><var>zip-archive</var><dd><a name="index-g_t_0040code_007b_002do_007d-_0028_0040code_007bjarmake_007d_0029-19"></a>Name of the output uncompressed zip archive. If this switch is not specified,
then the default name is <samp><span class="file">gnapplet.jar</span></samp>.

     <br><dt><code>-q</code><dd><a name="index-g_t_0040code_007b_002dq_007d-_0028_0040code_007bjarmake_007d_0029-20"></a>Quiet.

     <br><dt><code>-v</code><dd><a name="index-g_t_0040code_007b_002dv_007d-_0028_0040code_007bjarmake_007d_0029-21"></a>Verbose. 
</dl>

<div class="node">
<a name="Using-the-Java-API-with-jvm2ada"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Java_002dSpecific-Pragmas">Java-Specific Pragmas</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Building-Archives-with-jarmake">Building Archives with jarmake</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="chapter">6 Using the Java API with <code>jvm2ada</code></h2>

<!-- =========================================================================== -->
<p><a name="index-jvm2ada-22"></a>
The <code>jvm2ada</code> tool takes JVM <samp><span class="file">.class</span></samp> files as input (directly
or regrouped in an uncompressed <samp><span class="file">.zip</span></samp> or <samp><span class="file">.jar</span></samp> file) and
generates Ada specs as output.

<ul class="menu">
<li><a accesskey="1" href="#Running-jvm2ada">Running jvm2ada</a>
<li><a accesskey="2" href="#Switches-for-jvm2ada">Switches for jvm2ada</a>
<li><a accesskey="3" href="#Running-jvm2ada-on-the-Java-API">Running jvm2ada on the Java API</a>
<li><a accesskey="4" href="#Parameter-Names-and-Source-Search-Paths">Parameter Names and Source Search Paths</a>
<li><a accesskey="5" href="#Class-File-Search-Paths">Class File Search Paths</a>
<li><a accesskey="6" href="#Identifier-Mangling">Identifier Mangling</a>
</ul>

<div class="node">
<a name="Running-jvm2ada"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Switches-for-jvm2ada">Switches for jvm2ada</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-the-Java-API-with-jvm2ada">Using the Java API with jvm2ada</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Using-the-Java-API-with-jvm2ada">Using the Java API with jvm2ada</a>

</div>

<h3 class="section">6.1 Running <code>jvm2ada</code></h3>

<!--  -->
<p class="noindent">The form of the <code>jvm2ada</code> command is

<pre class="smallexample">     jvm2ada [<var>switches</var>] <var>file</var> [<var>file</var> ... <var>file</var>]
</pre>
   <p class="noindent">where <var>file</var> can be any of the following:

     <ul>
<li>the name of a <samp><span class="file">.class</span></samp> file (possibly without the <samp><span class="file">.class</span></samp> suffix);

     <li>the name of an uncompressed zip archive (in this case the <code>jvm2ada</code>
command applies to all <samp><span class="file">.class</span></samp> files within the archive);

     <li>the name of a <samp><span class="file">.class</span></samp> file within an uncompressed zip or jar archive <br>
(e.g. <samp><span class="file">rt.jar/java/lang/Object.class</span></samp>). 
</ul>

<p class="noindent">File names can be prefixed with directory information.

   <p>The output of <code>jvm2ada</code> is an Ada source file for each <samp><span class="file">.class</span></samp>
file processed. The Ada source file contains a package spec giving the Ada
declaration for the services exported by the corresponding <samp><span class="file">.class</span></samp>
file.  The name of the Ada package is obtained by concatenating the name of
the Java class to the name of the Java package containing the class. As an
example, a Java class <code>someName</code> occurring within Java package
<code>some.pack</code> yields the Ada package <code>some.pack.someName</code> and
is in a file named <samp><span class="file">some-pack-somename.ads</span></samp>.

   <p>Unless switch &lsquo;<samp><span class="samp">-o</span></samp>&rsquo; is used (see <a href="#Switches-for-jvm2ada">Switches for jvm2ada</a>), the Ada files
generated are placed in the directory where the <code>jvm2ada</code> command is
invoked.

<div class="node">
<a name="Switches-for-jvm2ada"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Running-jvm2ada-on-the-Java-API">Running jvm2ada on the Java API</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Running-jvm2ada">Running jvm2ada</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Using-the-Java-API-with-jvm2ada">Using the Java API with jvm2ada</a>

</div>

<h3 class="section">6.2 Switches for <code>jvm2ada</code></h3>

<!--  -->
<p class="noindent">The following switches are available with the <code>jvm2ada</code> utility:

     <dl>
<dt><code>-I</code><var>zip-archive</var><dd><a name="index-g_t_0040code_007b_002dI_007d-_0028_0040code_007bjvm2ada_007d_0029-23"></a>When looking for a source file (to find the parameter names of a Java method),
search the uncompressed zip archive <var>zip-archive</var>.  See <a href="#Parameter-Names-and-Source-Search-Paths">Parameter Names and Source Search Paths</a>, for details. (This switch is not yet
supported.)

     <br><dt><code>-L</code><var>zip-archive</var><dd><a name="index-g_t_0040code_007b_002dL_007d-_0028_0040code_007bjvm2ada_007d_0029-24"></a>When searching for <samp><span class="file">.class</span></samp> files, look in the uncompressed zip archive
<var>zip-archive</var>. See <a href="#Class-File-Search-Paths">Class File Search Paths</a>, for details.

     <br><dt><code>-k</code><dd><a name="index-g_t_0040code_007b_002dk_007d-_0028_0040code_007bjvm2ada_007d_0029-25"></a>Keep original JVM identifiers. By default, identifiers encountered in a
JVM .class file are mangled whenever needed to turn them into proper Ada
identifiers. When this switch is set, identifiers are left as is in the
generated Ada package spec. See <a href="#Identifier-Mangling">Identifier Mangling</a>, for details.

     <br><dt><code>-o </code><var>dir</var><dd><a name="index-g_t_0040code_007b_002do_007d-_0028_0040code_007bjvm2ada_007d_0029-26"></a>Output to <var>dir</var>. Put all generated Ada source files into directory <var>dir</var>
rather than the current directory.

     <br><dt><code>-q</code><dd><a name="index-g_t_0040code_007b_002dq_007d-_0028_0040code_007bjvm2ada_007d_0029-27"></a>Quiet.

     <br><dt><code>-s</code><dd><a name="index-g_t_0040code_007b_002ds_007d-_0028_0040code_007bjvm2ada_007d_0029-28"></a>Map Sun-specific classes into Ada specs. By default, Sun's classes are
not mapped into Ada even if they are public, because they are typically not
part of the API at hand (certainly they are not part of the Java API, even
though the corresponding jar file contains them). Sun's classes are the classes
in packages <code>sun</code>, <code>sunw</code>, and <code>com.sun</code>.

     <br><dt><code>-v</code><dd><a name="index-g_t_0040code_007b_002dv_007d-_0028_0040code_007bjvm2ada_007d_0029-29"></a>Verbose.

     <br><dt><code>-w</code><dd><a name="index-g_t_0040code_007b_002dw_007d-_0028_0040code_007bjvm2ada_007d_0029-30"></a>Overwrite existing file names. Normally <code>jvm2ada</code> regards it as a fatal
error if there is already a file with the same name as a file it would
otherwise output. This switch bypasses this check, and any such existing
files will be silently overwritten. 
</dl>

<div class="node">
<a name="Running-jvm2ada-on-the-Java-API"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Parameter-Names-and-Source-Search-Paths">Parameter Names and Source Search Paths</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Switches-for-jvm2ada">Switches for jvm2ada</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Using-the-Java-API-with-jvm2ada">Using the Java API with jvm2ada</a>

</div>

<h3 class="section">6.3 Running jvm2ada on the Java API</h3>

<!--  -->
<p class="noindent">In this section, we'll assume that the environment variable <code>JAVA_SDK</code>
points to the root installation of your java SDK (e.g. /jdk-1.5.0/).

<p class="noindent">To be able to access the Java API you need to process it to generate an Ada
package spec for each public class in the API. In order to manually do that,
you will need first to create a uncompressed version of the jce.jar file:

<pre class="smallexample">     $ jar -xf "$JAVA_SDK/jre/lib/jce.jar"
     $ jar -0cf uncompressed_jce.jar javax META-IN
</pre>
   <p class="noindent">then, run jvm2ada on the Java library archives (rt.jar, uncompressed_jce.jar,
charsets.jar and jsse.jar).

<pre class="smallexample">     $ jvm2ada -jgnat "$JAVA_SDK/jre/lib/rt.jar" \
        "-Luncompressed_jce.jar" \
        "-L$JAVA_SDK/jre/lib/charsets.jar" \
        "-L$JAVA_SDK/jre/lib/jsse.jar"
</pre>
   <p class="noindent">This will create, in the current directory, an Ada package spec
for each public Java class. If you would like to output the Ada specs in some
other directory use <code>jvm2ada</code> switch <code>-o</code>.

<p class="noindent">It's possible peform this operation automatically, in a single command, using
the script <code>bind_jre.sh</code>  (or <code>bind_jre.cmd</code> on windows):

<pre class="smallexample">     $ bind_jre.sh $JAVA_SDK
</pre>
   <p class="noindent">Please note that because of some jvm2ada limitations, you may have compilation
errors with some of the generated packages. The most common one is a name clash,
for example:

<pre class="smallexample">     java-util-concurrent-locks-reentrantreadwritelock.ads:54:13: "WriteLock"
     conflicts with declaration at
     java-util-concurrent-locks-reentrantreadwritelock-writelock.ads:9
</pre>
   <p class="noindent">In order to fix this kind of conflict, you will need to edit the Ada generated
code and fix manually the name clash, for example by adding a suffix <code>"_C"</code>
to the declaration of <code>WriteLock</code> at line 54.

<p class="noindent">In case of a more complex problem, the generic workaround is to manually wrap
the class into a simpler interface, and then use the resulting binding of this
interface. This occurs on very rare cases, the large majority of the generated
binding from the API being usable without any change.

<div class="node">
<a name="Parameter-Names-and-Source-Search-Paths"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Class-File-Search-Paths">Class File Search Paths</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Running-jvm2ada-on-the-Java-API">Running jvm2ada on the Java API</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Using-the-Java-API-with-jvm2ada">Using the Java API with jvm2ada</a>

</div>

<h3 class="section">6.4 Parameter Names and Source Search Paths</h3>

<!--  -->
<p class="noindent">Note: Only point 2. below is implemented.

<p class="noindent">When generating the Ada spec for a <samp><span class="file">.class</span></samp> file, <code>jvm2ada</code> tries
to preserve the original names of method parameters.  If the <samp><span class="file">.class</span></samp>
file was compiled enabling the generation of debugging tables (switch
&lsquo;<samp><span class="samp">-g</span></samp>&rsquo; in Sun's JDK <code>javac</code> compiler), parameter names are stored in
the <code>.class</code> file. If not <code>jvm2ada</code>
proceeds as follows:

     <ol type=1 start=1>
<li>If the name of the original source file is present in the <samp><span class="file">.class</span></samp>
file, <code>jvm2ada</code> tries to locate this source by looking at the
uncompressed zip archives specified by the <code>-I</code><var>zip-archive</var>
switches, in the order in which these switches occur.  Once found,
<code>jvm2ada</code> uses the source file to locate parameter names. If the
original source is not around you can always communicate parameter names by
creating a Java source file containing the appropriate method specs. For
instance to give the names of the parameters of method <code>someMethod</code> in
class <code>someClass</code> in package <code>some_package</code> you could create the
following source file:

     <pre class="smallexample">          package some_package;
          <i>//  You must provide the appropriate Java package for</i> someClass
          
          public class someClass {
             public int someMethod (int someName, float anotherName) {}
             <i>//  The methods for which you want to name the parameters must have the</i>
             <i>//  same signature as the methods found in the .class file. The body</i>
             <i>//  can be empty.</i>
          }
</pre>
     <li>If the appropriate source file cannot be located <code>jvm2ada</code> assigns
arbitrary parameter names of the form <code>P1_</code><i>type</i>,
<code>P2_</code><i>type</i>, etc. where <i>type</i> denotes the flattened type name
for the corresponding parameter. The reason for appending <i>type</i> to
the parameter name is to allow the Ada programmer to resolve possible
overloading resolution conflicts of the following kind

     <pre class="smallexample">          public class Base { }
          public class Deriv extends Base {
             public static void p (Base  obj) { ... }
             public static void p (Deriv obj) { ... }
          }
</pre>
     <p class="noindent">The overloaded procedure <code>p</code> above are translated by <code>jvm2ada</code>
to the following Ada specs:

     <pre class="smallexample">          procedure p (P1_Base  : access Base.Typ'Class);
          procedure p (P1_Deriv : access Deriv.Typ'Class);
</pre>
     <p class="noindent">The problem that arises is shown by the following example:

     <pre class="smallexample">          type Deriv_Ref is access all Deriv.Typ'Class;
          Obj : Deriv_Ref := ...;
          procedure p (Obj);              --  Ambiguos call
          procedure p (P1_Base  =&gt; Obj);  --  OK
          procedure p (P1_Deriv =&gt; Obj);  --  OK
</pre>
        </ol>

<div class="node">
<a name="Class-File-Search-Paths"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Identifier-Mangling">Identifier Mangling</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Parameter-Names-and-Source-Search-Paths">Parameter Names and Source Search Paths</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Using-the-Java-API-with-jvm2ada">Using the Java API with jvm2ada</a>

</div>

<h3 class="section">6.5 Class File Search Paths</h3>

<!--  -->
<p class="noindent">When processing a <samp><span class="file">.class</span></samp> file, <code>jvm2ada</code> may need to locate other
<samp><span class="file">.class</span></samp> files.  For instance, to know whether the JVM class being
processed is a Java exception, <code>jvm2ada</code> must traverse the inheritance
tree and must therefore locate the <samp><span class="file">.class</span></samp> files of the ancestor
classes.

   <p>If <code>jvm2ada</code> does not find the <samp><span class="file">.class</span></samp> file it is looking for,
then a warning message is emitted. The order in which <code>jvm2ada</code> searches
<samp><span class="file">.class</span></samp> files is given below.

     <ol type=1 start=1>
<li>If the <samp><span class="file">.class</span></samp> file being processed belongs to an uncompressed zip
archive, <code>jvm2ada</code> will look there first.

     <li>The uncompressed zip archives specified by a <code>-L</code><var>zip-archive</var>
switch are searched next, in the order in which the &lsquo;<samp><span class="samp">-L</span></samp>&rsquo; switches occur.
        </ol>

<div class="node">
<a name="Identifier-Mangling"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Class-File-Search-Paths">Class File Search Paths</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Using-the-Java-API-with-jvm2ada">Using the Java API with jvm2ada</a>

</div>

<h3 class="section">6.6 Identifier Mangling</h3>

<!--  -->
<p class="noindent"><code>jvm2ada</code> retains, whenever possible, the identifiers it finds in the
<samp><span class="file">.class</span></samp> files it processes. This is not always possible, however,
because Java's set of legal identifiers is bigger than Ada's. To address
these issues <code>jvm2ada</code> proceeds as follows: If switch <code>-k</code> is set,
the original identifiers found in the JVM .class are left unchanged. You
will have to change these yourself in the generated packages if these are
illegal Ada identifiers. If switch <code>-k</code> is not set then:

     <ul>
<li>Every identifier which is an Ada reserved word or any of the words
&ldquo;<code>Standard</code>&rdquo;, &ldquo;<code>Ref</code>&rdquo;, &ldquo;<code>Typ</code>&rdquo;, &ldquo;<code>Arr</code>&rdquo;,
&ldquo;<code>Arr_2</code>&rdquo;, &ldquo;<code>Arr_3</code>&rdquo;, is suffixed with <code>_K</code>. For instance,
<code>Abort</code> is mapped to <code>Abort_K</code>.

     <li>A single underscore is replaced by &ldquo;<code>U</code>&rdquo;.

     <li>A leading underscore is replaced by &ldquo;<code>U_</code>&rdquo;.

     <li>A trailing underscore is replaced by &ldquo;<code>_U</code>&rdquo;.

     <li>A letter &ldquo;<code>U</code>&rdquo; is placed between every two consecutive underscores.

     <li>If two or more identifiers generated in an Ada spec lead to an Ada name
conflict, then <code>jvm2ada</code> will add a trailing <code>_K</code> at the end
of the second occurrence, a trailing <code>_K2</code> at the end of the third
occurrence, a trailing <code>_K3</code> at the end of the fourth occurrence, etc. 
The cases currently caught are: identical variable names, identical variable
and subprogram names, identical variable and child package name.  More complex
cases are not yet handled. In particular, we do not yet detect the case where
we have two identical field names in a record <code>B</code> and a record <code>D</code>
derived from <code>B</code>. In these cases you will have to revise the generated
Ada spec to allow it to compile. 
</ul>

<div class="node">
<a name="Java-Specific-Pragmas"></a>
<a name="Java_002dSpecific-Pragmas"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-the-Java-API-with-jvm2ada">Using the Java API with jvm2ada</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="chapter">7 Java-Specific Pragmas</h2>

<!-- =========================================================================== -->
<p class="noindent">The typical way to import services from Java classes is to use the
<code>jvm2ada</code> tool to automatically generate the specification of the
corresponding <samp><span class="file">.class</span></samp> file. This specification contains the
appropriate Java-specific pragmas.

   <p>In some cases you may wish to import just one routine to your Ada code
or you may prefer to group certain services from multiple <samp><span class="file">.class</span></samp>
files into a single Ada spec (for instance if you are trying to provide
a simplified view of the Java API).

   <p>In such cases it is useful to understand how the various Java-specific
pragmas work. Another situation where you may have to use these pragmas
explicitly is when exporting Ada services to Java.

   <p>This chapter introduces the features and pragmas that are needed for full
support of interfacing between Java and Ada.

<ul class="menu">
<li><a accesskey="1" href="#Creating-Java-Interfaces-with-Pragma-Java_005fInterface">Creating Java Interfaces with Pragma Java_Interface</a>
<li><a accesskey="2" href="#Using-Java-Interfaces">Using Java Interfaces</a>
<li><a accesskey="3" href="#The-Java_005fConstructor-Pragma">The Java_Constructor Pragma</a>
<li><a accesskey="4" href="#Pragma-Import-Java">Pragma Import Java</a>
<li><a accesskey="5" href="#Pragma-Export-Java">Pragma Export Java</a>
</ul>

<div class="node">
<a name="Creating-Java-Interfaces-with-Pragma-Java_Interface"></a>
<a name="Creating-Java-Interfaces-with-Pragma-Java_005fInterface"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-Java-Interfaces">Using Java Interfaces</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Java_002dSpecific-Pragmas">Java-Specific Pragmas</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Java_002dSpecific-Pragmas">Java-Specific Pragmas</a>

</div>

<h3 class="section">7.1 Creating Java Interfaces: Pragma <code>Java_Interface</code></h3>

<!--  -->
<p class="noindent">Java offers a special kind of class called an interface. Interfaces
provide a limited but useful form of multiple inheritance. A Java
interface is basically an abstract class with no fields and whose methods
are all abstract. Instead of inheriting from an interface, a Java class
<code>C</code> is said to implement the interface, which means that <code>C</code>
must provide an implementation for all of the abstract methods declared
in the interface.

   <p>The key point to note about interfaces is that a class <code>C</code> can
implement several interfaces at the same time, and this mechanism is
orthogonal to the fact that <code>C</code> may be extending some other class.

   <p>To make a Java interface available to an Ada program we have
provided the pragma <code>Java_Interface</code>. Its syntax is:

<pre class="smallexample">     pragma Java_Interface (<var>type-name</var>);
</pre>
   <p class="noindent">where <var>type-name</var> is the name of a type <var>T</var> declared earlier,
immediately within the same declarative part where the pragma occurs, and
where the type has the following characteristics that reflect the restrictions
on Java interfaces:

     <ol type=1 start=1>
<li><var>T</var> must be an abstract tagged type with a null record extension.

     <li><var>T</var> must be derived from <code>java.lang.Object.Typ</code>
(see <a href="#Java-References-and-java_002elang_002eObject">Java References and java.lang.Object</a>).

     <li><var>T</var> must have an access discriminant named <code>Self</code> with
<code>java.lang.Object.Typ'Class</code> as its designated type.

     <li>All of <var>T</var>'s primitive operations must be abstract.

     <li><var>T</var> must have Java <code>Convention</code>.
        </ol>

<p class="noindent">Here is an example of using pragma <code>Java_Interface</code>:

<pre class="smallexample">     with java.lang.Object;
     package Foo is
        type Typ (Self : access java.lang.Object.Typ'Class)
          is abstract new java.lang.Object.Typ with null record;
        pragma Java_Interface (Typ);
     
        type Ref is access all Typ'Class;
     
        procedure Proc (This : access Typ; Val : Integer) is abstract;
        function  Func (This : access Typ) return Integer is abstract;
     
     private
        pragma Convention (Java, Typ);
     end Foo;
</pre>
   <div class="node">
<a name="Using-Java-Interfaces"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-Java_005fConstructor-Pragma">The Java_Constructor Pragma</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Creating-Java-Interfaces-with-Pragma-Java_005fInterface">Creating Java Interfaces with Pragma Java_Interface</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Java_002dSpecific-Pragmas">Java-Specific Pragmas</a>

</div>

<h3 class="section">7.2 Using Java Interfaces</h3>

<!--  -->
<p class="noindent">In order to declare an Ada type that implements one or more Java interfaces
it is necessary to use a simple programming idiom that is specially
recognized by the compiler. This mechanism is not restricted for use only
with types imported from Java, but can be applied to any Ada tagged type
<var>T</var>.

   <p>The idiom consists in specifying a discriminant <var>D</var> for each Java
interface <var>Interf</var> that type <var>T</var> implements. The type of <var>D</var> must
be some access type whose designated type is <var>Interf</var>.  Discriminants such
as <var>D</var> are not represented by an actual field in the object, but rather
serve as a symbolic shorthand to indicate the special characteristics of
type <var>T</var> to the compiler.

   <p>As an example, the following package spec declares a type <code>Bar.Typ</code>
which implements interface <code>Foo.Typ</code>:

<pre class="smallexample">     with Foo;
     package Bar is
        type Typ (Foo_I : Foo.Ref) is tagged record
           Field : Integer;
        end record;
        --  <i>Discriminant</i> Foo_I <i>above signals that</i> Bar.Typ <i>implements the</i>
        --  Foo.Typ <i>interface (</i>Foo_I <i>stands for</i> Foo <i>Interface). The</i>
        --  <i>compiler does not create a field for</i> Foo_I <i>but marks the</i>
        --  <i>generated .class file as implementing interface</i> Foo.Typ.
     
        procedure Proc (This : access Typ; Val : Integer);
        function  Func (This : access Typ) return Integer;
        --  <i>Unless</i> Bar.Typ <i>is itself marked abstract,</i> Bar.Typ <i>must</i>
        --  <i>provide an implementation for subprograms</i> Proc <i>and</i> Func.
        --  <i>Right now if you omit these subprograms the GNAT compiler will not</i>
        --  <i>complain, but when loading the .class file corresponding to</i> Bar.Typ
        --  <i>the JVM will halt execution with a verifier error</i>.
     end Bar;
</pre>
   <p class="noindent">As mentioned in the example, unless <var>T</var> is abstract, <var>T</var> must
provide an implementation for each of the abstract operations of the
<var>Interf</var> interface (currently this check is not done by the GNAT
compiler but is caught later on by the JVM).

   <p>A second use of these special interface discriminants is to enable
conversions between pointers to type <var>T</var> and pointers of its
implemented interface types as the example below demostrates.

<pre class="smallexample">     with Foo;
     with Bar;
     package Client is
        X : Bar.Ref := new Bar.Typ (null);
        --  <i>Create an object of type</i> Bar.Typ. <i>To satisfy Ada's semantic rules</i>
        --  <i>we must provide a value for</i> Foo_I<i>, but this value is ignored.</i>
     
        Y : Foo.Ref := X.Foo_I;
        --  <i>OK, upward conversion allowed, no checks.</i>
        --  <i>Referencing discriminant</i> Foo_I <i>is a convenient way to convert</i> X
        --  <i>to a</i> Foo.Ref<i>. The compiler transorms all references to</i> Foo_I
        --  <i>into references to the selector itself, in this case</i> X.
     
        Val : Integer := Foo.Func (Y);
        --  <i>Dispatching call</i>
     end Client;
</pre>
   <p>A conversion can also be made from an object of the class-wide interface
reference type to an implementing reference type, by selecting the
<code>Self</code> field (which is of type <code>java.lang.Object.Typ'Class</code>), and
then applying a downward tagged type conversion (assuming that <var>T</var>
derives directly or indirectly from <code>java.lang.Object</code>). Such a
downward conversion will involve a run-time check, to ensure that the
source object belongs to the target type's class. The package spec below
illustrates one such downward conversion.

<pre class="smallexample">     with Foo;
     with java.lang.Object;
     package Zar is
        type Typ (Foo_I : Foo.Ref) is new java.lang.Object.Typ with record
           Field : Integer;
        end record;
     
        type Ref is access all Typ'Class;
     
        procedure Proc (This : access Typ; Val : Integer);
        function  Func (This : access Typ) return Integer;
     
        X : Zar.Ref := new Zar.Typ (null);
        Y : Foo.Ref := X.Foo_I;
     
        Z : Zar.Ref := Zar.Ref (Y.Self);
        --  <i>OK, downward conversion, run-time check that</i> Y <i>designates an</i>
        --  <i>object in</i> Zar.Obj'Class.
        --  <i>Again the compiler ignores the special discriminant</i> Self <i>and</i>
        --  <i>returns the selector itself, in this case</i> Y.
     end Zar;
</pre>
   <p class="noindent">In both of the cases shown above, the compiler recognizes the special
idiom of selecting the interface or <code>Self</code> discriminant as meaning
a reference to the object itself, reinterpreting the type of the
object appropriately.

   <p>The above mechanism can also be used within another <code>Java_Interface</code>
type as illustrated by the following example:

<pre class="smallexample">     with java.lang.Object;
     package Zoo is
        type Typ (Self : access java.lang.Object.Typ'Class) is
          new abstract java.lang.Object.Typ with null record;
        pragma Java_Interface (Typ);
     
        type Ref is access all Typ'Class;
     
        procedure Interface_Op (This : access Typ) is abstract;
     private
        pragma Convention (Java, Typ);
     end Zoo;
     
     with java.lang.Object; use java.lang.Object;
     with Foo;
     with Zoo;
     package Woo is
        type Typ (Foo_I : Foo.Ref;
                  Zoo_I : Zoo.Ref)
          is new abstract java.lang.Object.Typ with null record;
        pragma Java_Interface (Typ);
     
        type Ref is access all Typ'Class;
     
        --  <i>Woo must list all of the abstract operations of interfaces</i>
        --  <i>Foo and Zoo.</i>
     
        procedure Proc (This : access Typ; Val : Integer) is abstract;
        function  Func (This : access Typ) return Integer is abstract;
        procedure Interface_Op (This : access Typ) is abstract;
     
        procedure New_Op (This : access Typ) is abstract;
        --  <i>A new operation of the interface</i>
     private
        pragma Convention (Java, Typ);
     end Woo;
</pre>
   <p class="noindent">Another interesting example is the declaration of a type <code>Bar.Child.Typ</code>
that derives from <code>Bar.Typ</code> and implements interface <code>Woo.Typ</code>,
as shown below:

<pre class="smallexample">     with Foo;
     with Woo;
     package Bar.Child is
        type Typ (Foo_I : Foo.Ref;
                  Woo_I : Woo.ref)
          is new Bar.Typ (Foo_I) with null record;
        --  <i>Note how</i> Foo_I <i>is used to constrain</i> Bar.Typ<i>. This is just to</i>
        --  <i>satisfy Ada semantics requirements and has no other implications.</i>
     
        type Ref is access all Typ'Class;
     
        procedure Proc (This : access Typ; Val : Integer);
        function  Func (This : access Typ) return Integer;
        procedure Interface_Op (This : access Typ);
        procedure New_Op (This : access Typ);
     end Woo;
     
</pre>
   <p class="noindent">An interesting point to note is when an Ada tagged type <code>Deriv</code> derives
from an Ada tagged type <code>Base</code> which implements a number of
interfaces. If <code>Deriv</code> does not implement any additional interface
there is no need to specify interface discriminants for <code>Deriv</code>, since
it can simply inherit those of <code>Base</code>.

<div class="node">
<a name="The-Java_Constructor-Pragma"></a>
<a name="The-Java_005fConstructor-Pragma"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Pragma-Import-Java">Pragma Import Java</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-Java-Interfaces">Using Java Interfaces</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Java_002dSpecific-Pragmas">Java-Specific Pragmas</a>

</div>

<h3 class="section">7.3 The <code>Java_Constructor</code> Pragma</h3>

<!--  -->
<ul class="menu">
<li><a accesskey="1" href="#Background-on-Java-Constructors">Background on Java Constructors</a>
<li><a accesskey="2" href="#Using-Java-Constructors-in-Ada">Using Java Constructors in Ada</a>
<li><a accesskey="3" href="#Java-Constructors-and-Ada-Allocators">Java Constructors and Ada Allocators</a>
</ul>

<div class="node">
<a name="Background-on-Java-Constructors"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-Java-Constructors-in-Ada">Using Java Constructors in Ada</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-Java_005fConstructor-Pragma">The Java_Constructor Pragma</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Java_005fConstructor-Pragma">The Java_Constructor Pragma</a>

</div>

<h4 class="subsection">7.3.1 Background on Java Constructors</h4>

<!-- ........................................................................... -->
<p class="noindent">A Java constructor is a special method that must be invoked immediately
after allocating an object, in order to initialize the object. Given
the following Java class:

<pre class="smallexample">     public class C {
        public int field;
        public C ()      { field = 3; }
        public C (int i) { field = i; }
     }
</pre>
   <p class="noindent">then the statement <code>C obj = new C (3)</code> accomplishes two things:

     <ol type=1 start=1>
<li>It allocates a new instance of class <code>C</code> in the Java heap and sets
<code>obj</code> to point to this object;

     <li>It then calls the constructor that takes an <code>int</code> parameter, passing
<code>obj</code> to it as a hidden parameter and the value 3 for its <code>int</code>
parameter.
        </ol>

<p class="noindent">If no constructor is provided, as in the following class:

<pre class="smallexample">     class D extends C {
        float f;
     }
</pre>
   <p class="noindent">then a default constructor

<pre class="smallexample">     public D () {
        super ();
     }
</pre>
   <p class="noindent">is automatically generated for class <code>D</code>. The call of <code>super()</code>
inside this default constructor (known as a <em>no-arg</em> constructor)
invokes the no-arg constructor of the superclass of <code>D</code>, that is, the
constructor of class <code>C</code>.

   <p>Generally speaking, the first statement of every constructor must either be
a call to another constructor of the class, or a call to a constructor of
the superclass. For instance, given a constructor

<pre class="smallexample">     public C (int i, int j) { this (i + j); }
</pre>
   <p class="noindent">The call <code>this (...)</code> invokes another constructor in the same class
whose profile matches the parameters specified in <code>(...)</code>. As another
example, consider:

<pre class="smallexample">     public D (int k) { super (k); }
</pre>
   <p class="noindent">where again <code>super (...)</code> invokes a constructor in the superclass
whose profile matches the parameters specified in <code>(...)</code>.

   <p>The observant reader will note that in both of the original constructors of
class C, there are no calls to either <code>this (...)</code> or <code>super
(...)</code>. When no such call is explicitly given, the Java compiler
automatically inserts calls to the no-arg constructor in the superclass. If
the superclass does not have a no-arg constructor (more on this below),
then you must explicitly insert calls to <code>super (...)</code>  or <code>this
(...)</code>.

   <p>As noted above, a class might not have a no-arg constructor. This can occur
only when explicit constructors are defined in the class.  In this case,
the no-arg constructor is not automatically generated for the class, and if
a no-arg constructor is desired, you must add it yourself. For instance, in
the following class:

<pre class="smallexample">     public class A {
        int ival;
        public A (int i) { ival = i; }
     }
     
     public class B extends A {
        float fval;
        public B (float f) { fval = f; }
     }
</pre>
   <p class="noindent">the Java compiler will issue a compile-time error reporting that no
constructor matching <code>A ()</code> was found in class <code>A</code>, because the
compiler tries to insert such a call at the beginning of <code>B</code>. To
correct this problem the Java programmer must either add a no-arg
constructor <code>A ()</code> in class <code>A</code>, or else change the definition of
<code>B</code>'s constructor to contain an explicit constructor, e.g., as
follows:

<pre class="smallexample">     public B (float f) {
       super (0);
       fval = f;
     }
</pre>
   <div class="node">
<a name="Using-Java-Constructors-in-Ada"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Java-Constructors-and-Ada-Allocators">Java Constructors and Ada Allocators</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Background-on-Java-Constructors">Background on Java Constructors</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Java_005fConstructor-Pragma">The Java_Constructor Pragma</a>

</div>

<h4 class="subsection">7.3.2 Using Java Constructors in Ada</h4>

<!-- .......................................................................... -->
<p class="noindent">To assert that an Ada function <var>function-name</var> should be mapped to a
Java constructor of some Ada <var>tagged-type</var>, we have introduced the
<code>Java_Constructor</code> pragma. Its syntax is as follows:

<pre class="smallexample">     pragma Java_Constructor (<var>function-name</var>);
</pre>
   <p class="noindent">where <var>function-name</var> is the name of a function declared immediately
within the same declarative part where the pragma occurs, and the function
must have the following characteristics:

     <ol type=1 start=1>
<li>The function's result type is an access type designating a class-wide
type with convention Java declared at the same declarative level as the
function (<code>access </code><var>tagged-type</var><code>'Class</code>);

     <li>The first function parameter is named <code>This</code>, and its type is a
named access type designating <var>tagged-type</var><code>'Class</code> which may
have a <code>null</code> default value;

     <li>If the constructor invokes other constructor then the first declaration
in the function body should contain an object declaration with a default
initial expression of the form <var>constructor-func</var><code> (..., This)</code>,
where the <var>constructor-func</var> is a <code>Java_Constructor</code> function which
belongs either to <var>tagged-type</var> or to the parent type of <var>tagged-type</var>;
        </ol>

<p class="noindent">The effect of a <code>Java_Constructor</code> pragma is to compile
<var>function-name</var> into a constructor for the class corresponding to
<var>tagged-type</var>.  In addition, whenever <var>function-name</var> is invoked
with a <code>null</code> value for parameter <code>This</code>, the compiler calls the
<code>tagged-type</code> object allocator and passes in the pointer to the newly
allocated object in lieu of the value <code>null</code>.

   <p>A <code>Java_Constructor</code> pragma is a program unit pragma. It can appear in
the same places where an <code>Inline</code> pragma for <var>function-name</var> can
appear. The <code>Java_Constructor</code> pragma applies to all the overloaded
<var>function-name</var> subprograms declared immediately within the declarative
region containing the pragma.

   <p>As an example, the following Java code:

<pre class="smallexample">     public class C {
        public int field;
        public C ()             { field = 3; }
        public C (int i)        { field = i; }
        public C (int i, int j) { this (i + j); }
     }
</pre>
   <p class="noindent">is equivalent to the following Ada:

<pre class="smallexample">     with java.lang.Object;  --  <i>more on this package in the coming sections</i>
     use  java.lang.Object;
     package C is
        use java.lang;
     
        type Typ is new java.lang.Object.Typ with record
           Field : Integer;
        end record;
     
        type Ref is access all Typ'Class;
     
        function new_C (This : Ref := null) return Ref;
        function new_C (I : Integer; This : Ref := null) return Ref;
        function new_C (I, J : Integer; This : Ref := null) return Ref;
     
     private
        pragma Java_Constructor (new_C);
     end C;
     
     package body C is
        function new_C (This : Ref := null) return Ref is
           Super : Object.Ref := Object.new_Object (Object.Ref (This));
        begin
           This.Field := 3;
           return This;
        end new_C;
     
        function new_C (I : Integer; This : Ref := null) return Ref is
           Super : Object.Ref := Object.new_Object (Object.Ref (This));
        begin
           This.Field := I;
           return This;
        end new_C;
     
        function new_C (I, J : Integer; This : Ref := null) return Ref is
           Ignore : Ref := new_C (I + J, This);
        begin
           return This;
        end new_C;
     end C;
</pre>
   <div class="node">
<a name="Java-Constructors-and-Ada-Allocators"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-Java-Constructors-in-Ada">Using Java Constructors in Ada</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Java_005fConstructor-Pragma">The Java_Constructor Pragma</a>

</div>

<h4 class="subsection">7.3.3 Java Constructors and Ada Allocators</h4>

<!-- .......................................................................... -->
<p class="noindent">An interesting question raised by the <code>Java_Constructor</code> pragma is
the interaction between Ada allocators and constructors. 
For instance a client of package <code>C</code> given in the previous section
could write:

<pre class="smallexample">     with C;
     procedure Client is
        Obj_1 : C.Ref := new_C;
        Obj_2 : C.Ref := new C.Typ;  -- <i>what happens here ???</i>
</pre>
   <p class="noindent">What GNAT does in the allocator case is to call the no-arg constructor if
present (in the example <code>new_C (This : Ref := null)</code>). If there is no
no-arg constructor then an error is emitted by the GNAT compiler (this last
check is currently not yet supported, and there will be an exception at
run time).

<div class="node">
<a name="Pragma-Import-Java"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Pragma-Export-Java">Pragma Export Java</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-Java_005fConstructor-Pragma">The Java_Constructor Pragma</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Java_002dSpecific-Pragmas">Java-Specific Pragmas</a>

</div>

<h3 class="section">7.4 Pragma Import Java</h3>

<!--  -->
<p class="noindent">For convention Java, pragma <code>Import</code> has the following syntax:

<pre class="smallexample">     pragma Import ([Convention    =&gt;] Java,
                    [Entity        =&gt;] <var>Local_Name</var>
                  [,[External_Name =&gt;] <var>String_Expression</var>]);
</pre>
   <p class="noindent">where <var>Local_Name</var> is the name of an object, subprogram, record
component, exception, or package, while <var>String_Expression</var> is a string
giving the Java name of the imported entity. If <var>String_Expression</var> is
missing it is taken to be the <var>Local_Name</var>, all in lower-case letters.

<ul class="menu">
<li><a accesskey="1" href="#Importing-Packages">Importing Packages</a>
<li><a accesskey="2" href="#Importing-Exceptions">Importing Exceptions</a>
<li><a accesskey="3" href="#Importing-Record-Components">Importing Record Components</a>
<li><a accesskey="4" href="#Importing-Dispatching-Subprograms">Importing Dispatching Subprograms</a>
<li><a accesskey="5" href="#Importing-Objects">Importing Objects</a>
<li><a accesskey="6" href="#Importing-Non_002dDispatching-Subprograms">Importing Non-Dispatching Subprograms</a>
</ul>

<div class="node">
<a name="Importing-Packages"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Importing-Exceptions">Importing Exceptions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pragma-Import-Java">Pragma Import Java</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragma-Import-Java">Pragma Import Java</a>

</div>

<h4 class="subsection">7.4.1 Importing Packages</h4>

<!-- ........................................................................... -->
<p class="noindent">If the <var>Local_Name</var> of an <code>Import</code> pragma is the name of a package
spec <var>P</var>, then all the entities declared in <var>P</var> must be
explicitly imported from Java. The <var>String_Expression</var> of such an
<code>Import</code> pragma gives the name of the Java class corresponding to
<var>P</var> and can be a simple class name or it can have the form
<var>java_package_name</var><code>.</code><var>class_name</var>, which indicates that the
class <var>class_name</var> corresponding to <var>P</var> belongs to Java package
<var>java_package_name</var>. If <var>java_package_name</var> is missing, the class
belongs to the anonymous Java package.

   <p>The precise rules when importing a package <var>P</var> are:

     <ul>
<li>All the entities declared inside <var>P</var> must be imported either by means
of the <code>Import</code> pragma or by using other Java-specific pragmas.

     <li><var>P</var> should contain at most one tagged or untagged record type whose
name must be <code>Typ</code>. <code>Typ</code> models the record part of the class
corresponding to <var>P</var>.

     <li><var>P</var> can contain at most one exception, whose <code>Import</code> pragma
must have exactly the same <var>String_Expression</var> as for <var>P</var>. (In
<code>jvm2ada</code> such an exception is present only if the class
corresponing to <var>P</var> derives, directly or indirectly, from class
<code>java.lang.Throwable</code>. The name we have selected for such an
exception is <code>Except</code>.)

     <li><var>P</var> should not contain task types or protected types.

     <li>The <var>String_Expression</var> of the <code>Import</code> pragma for an object,
subprogram, or record component declared in <var>P</var> must be a simple
name (it cannot contain any &ldquo;<code>.</code>&rdquo; characters).

     <li>If <var>P</var> contains nested packages, these must themselves contain an
<code>Import</code> pragma (and the above rules apply recursively). 
</ul>

<p class="noindent">As a first example consider the following package:

<pre class="smallexample">     with java.lang.Object; --  <i>more on this package in the coming sections</i>
     package root.outer.Child is
        type Typ is new java.lang.Object.Typ with record
           x : Integer;
           pragma Import (Java, x, "x");
     
           Y : Integer;
           pragma Import (Java, Y, "Y");
        end record;
     
        type Ref is access all Typ'Class;
     
        procedure Dispatching_Op (This : access Typ; I : Integer);
        function Non_Dispatching_Op (F : Float) return Integer;
     
        function New_Child (This : Ref := null) return Ref;
        Global : Integer;
     
     private
        pragma Import (Java, Dispatching_Op, "someProcedure");
        pragma Import (Java, Non_Dispatching_Op, "someFunction");
        pragma Java_Constructor (New_Child);
        pragma Import (Java, Global);
     end root.outer.Child;
     pragma Import (Java, Outer.Child, "root.outer.CHILD");
     
</pre>
   <p class="noindent">This package imports into Ada the services of a class whose spec in
Java looks like:

<pre class="smallexample">     
     package root.outer;
     public class CHILD extends java.lang.Object {
        public int x;
        public int Y;
     
        public void someProcedure (int i);
        public static int someFunction (float f);
     
        public CHILD ();
     
        public static int global;
     }
</pre>
   <p class="noindent">Note that in the Ada spec, the Java methods
<code>someProcedure</code> and <code>someFunction</code> have been named
<code>Dispatching_Op</code> and <code>Non_Dispatching_Op</code>.

<div class="node">
<a name="Importing-Exceptions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Importing-Record-Components">Importing Record Components</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Importing-Packages">Importing Packages</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragma-Import-Java">Pragma Import Java</a>

</div>

<h4 class="subsection">7.4.2 Importing Exceptions</h4>

<!-- ........................................................................... -->
<p class="noindent">If the <var>Local_Name</var> of an <code>Import</code> pragma is the name of an
exception <var>E</var>, the <var>String_Expression</var> of such an <code>Import</code>
pragma gives the name of the JVM class corresponding to <var>E</var> and can be
a simple class name or it can have the form
<var>java_package_name</var><code>.</code><var>class_name</var> which says that the JVM
class <var>class_name</var> corresponding to <var>E</var> belongs to Java package
<var>java_package_name</var>. If <var>java_package_name</var> is missing, the JVM
class belongs to the anonymous Java package.

   <p>When importing an exception you should make sure that the imported JVM
class is indeed a Java exception, i.e. it derives from
<code>java.lang.Throwable</code>.

   <p>As an example here is an excerpt of the spec of class
<code>java.lang.Throwable</code> generated by <code>jvm2ada</code>:

<pre class="smallexample">     package java.lang.Throwable is
        type Typ ...;
        type Ref is access all Typ'Class;
     
        Except : Exception;
        ...
     private
        pragma Import (Java, Except, "java.lang.Throwable);
        ...
     end java.lang.Throwable;
     pragma Import (Java, java.lang.Throwable, "java.lang.Throwable");
</pre>
   <div class="node">
<a name="Importing-Record-Components"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Importing-Dispatching-Subprograms">Importing Dispatching Subprograms</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Importing-Exceptions">Importing Exceptions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragma-Import-Java">Pragma Import Java</a>

</div>

<h4 class="subsection">7.4.3 Importing Record Components</h4>

<!-- ........................................................................... -->
<p class="noindent">If the <var>Local_Name</var> of an <code>Import</code> pragma is the name of a record
field, then the record field must be declared in a record whose convention
is Java and the record must be declared in a package specification which is
itself imported.  In this case <var>String_Expression</var> must be a simple name
(i.e. contains no dots) giving the name of the imported field.

<div class="node">
<a name="Importing-Dispatching-Subprograms"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Importing-Objects">Importing Objects</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Importing-Record-Components">Importing Record Components</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragma-Import-Java">Pragma Import Java</a>

</div>

<h4 class="subsection">7.4.4 Importing Dispatching Subprograms</h4>

<!-- ........................................................................... -->
<p class="noindent">If the <var>Local_Name</var> of an <code>Import</code> pragma is the name of a dispatching
subprogram (i.e., a primitive operation of a tagged type), then the subprogram
must be declared in a package specification which is itself imported. 
In this case <var>String_Expression</var> must be a simple name (i.e. contains
no dots) giving the name of the imported subprogram.

<div class="node">
<a name="Importing-Objects"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Importing-Non_002dDispatching-Subprograms">Importing Non-Dispatching Subprograms</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Importing-Dispatching-Subprograms">Importing Dispatching Subprograms</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragma-Import-Java">Pragma Import Java</a>

</div>

<h4 class="subsection">7.4.5 Importing Objects</h4>

<!-- ........................................................................... -->
<p class="noindent">If the <var>Local_Name</var> of an <code>Import</code> pragma is the name of an object
and the object is declared in a package specification which is itself
imported the <var>String_Expression</var> must be a simple name (i.e. contains no
dots) giving the name of the imported Java static field.

   <p>An <code>Import</code> pragma for an object can be given even though such an
entity does not occur in a package spec with an <code>Import</code> pragma. In
this case the <var>String_Expression</var> of the <code>Import</code> pragma must give
the complete Java name of the imported as shown in the following example:

<pre class="smallexample">     procedure Foo is
        Var : Integer;
        pragma Import (Java, Var, "pack.Foo.the_var");
     begin
        Var := 3;
     end Foo;
</pre>
   <div class="node">
<a name="Importing-Non-Dispatching-Subprograms"></a>
<a name="Importing-Non_002dDispatching-Subprograms"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Importing-Objects">Importing Objects</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragma-Import-Java">Pragma Import Java</a>

</div>

<h4 class="subsection">7.4.6 Importing Non-Dispatching Subprograms</h4>

<!-- ........................................................................... -->
<p class="noindent">If the <var>Local_Name</var> of an <code>Import</code> pragma is the name of a
non-dispatching subprogram and the subprogram is declared in a package
specification which is itself imported the <var>String_Expression</var> must be a
simple name (i.e. contains no dots) giving the name of the imported Java
static method.

   <p>An <code>Import</code> pragma for a non-dispatching subprogram can be given even
though such an entity does not occur in a package spec with an <code>Import</code>
pragma. In this case the <var>String_Expression</var> of the <code>Import</code> pragma
must give the complete Java name of the imported as shown in the following
example:

<pre class="smallexample">     procedure Foo is
        X : Integer;
        function Compute (I : Integer) return Integer;
        pragma Import (Java, Compute, "pack.Bar.calc");
     begin
        X := Compute (3);
     end Foo;
</pre>
   <div class="node">
<a name="Pragma-Export-Java"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pragma-Import-Java">Pragma Import Java</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Java_002dSpecific-Pragmas">Java-Specific Pragmas</a>

</div>

<h3 class="section">7.5 Pragma Export Java</h3>

<!--  -->
<p class="noindent">In the absence of pragma <code>Export</code>, the name of any Ada object,
field, or subprogram compiled into a class file is the name of the
corresponding Ada entity in lower-case letters.

   <p>For exceptions, record types and packages, the names of the generated class
files are all in lower case.

   <p>By using pragma <code>Export</code> the user can change the default name that
is generated by the GNAT compiler. In addition, for Ada packages
it can also specify which Java package they belong to. For convention
Java, the pragma <code>Export</code> has the following syntax:

<pre class="smallexample">     pragma Export ([Convention    =&gt;] Java,
                    [Entity        =&gt;] <var>Local_Name</var>
                  [,[External_Name =&gt;] <var>String_Expression</var>]);
</pre>
   <p class="noindent">where <var>Local_Name</var> is the name of an object, subprogram, record
component, record type, exception, or package, and <var>String_Expression</var>
is a string giving the Java name of the exported entity. If
<var>String_Expression</var> is missing it is taken to be the <var>Local_Name</var>,
all in lower-case letters.

<ul class="menu">
<li><a accesskey="1" href="#Exporting-Objects-Subprograms-and-Record-Components">Exporting Objects Subprograms and Record Components</a>
<li><a accesskey="2" href="#Exporting-Exceptions">Exporting Exceptions</a>
<li><a accesskey="3" href="#Exporting-Packages-or-Record-Types">Exporting Packages or Record Types</a>
</ul>

<div class="node">
<a name="Exporting-Objects-Subprograms-and-Record-Components"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Exporting-Exceptions">Exporting Exceptions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pragma-Export-Java">Pragma Export Java</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragma-Export-Java">Pragma Export Java</a>

</div>

<h4 class="subsection">7.5.1 Exporting Objects, Subprograms, and Record Components</h4>

<!-- ........................................................................... -->
<p class="noindent">NOTE: Exporting of record components is not yet supported. <br>

<p class="noindent">If the <var>Local_Name</var> of an <code>Export</code> pragma is the name of an
object, record component, or subprogram (but not a top-level subprogram),
<var>String_Expression</var> must be a simple name (i.e., it contains no
<code>.</code> characters), giving the name of the corresponding entity at the
JVM level. As an example, when compiling the following package specification:

<pre class="smallexample">     package C is
        type Typ is tagged record
           Field : Integer;
           pragma Export(Java, Field, "THE_FIELD");
        end record;
     
        function Instance_Op (This : access Typ; I : Integer) return Integer;
     
        Var : Integer;
        function Op (J : Integer) return Integer;
     
     private
        pragma Export (Java, Instance_Op, "dispatch_op");
        pragma Export (Java, Var, "the_var");
     end C;
</pre>
   <p class="noindent">this is interpreted as the following two class specification at the JVM
level:

<pre class="smallexample">     public class c {
        public static int the_var;
        public static int op (int j);
     }
     public class c$typ {
        public int THE_FIELD;
        public int dispatch_op (int i) {...}
     }
</pre>
   <p class="noindent">Note that when exporting an object, subprogram, or record component you
cannot specify its JVM class, as this is determined by the compiler.

<div class="node">
<a name="Exporting-Exceptions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Exporting-Packages-or-Record-Types">Exporting Packages or Record Types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Exporting-Objects-Subprograms-and-Record-Components">Exporting Objects Subprograms and Record Components</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragma-Export-Java">Pragma Export Java</a>

</div>

<h4 class="subsection">7.5.2 Exporting Exceptions</h4>

<!-- ........................................................................... -->
<p class="noindent">If the <var>Local_Name</var> of an <code>Export</code> pragma is the name of an
exception <var>E</var>, then the <var>String_Expression</var> of such an
<code>Export</code> pragma gives the name of the generated JVM class for the Ada
exception, overriding the name that would have been given by the
compiler. <var>String_Expression</var> can be a simple class name, or it can
have the form

<pre class="smallexample">     <var>java_package_name</var><code>.</code><var>class_name</var>
</pre>
   <p class="noindent">indicating that the generated class belongs to Java package
<var>java_package_name</var>.  If the name <var>java_package_name</var> is missing,
the class is defined to belong to the anonymous Java package.

   <p>Care must be taken not to use the same class name for two Ada exceptions,
packages or record types when they belong to different source files located
in the same directory, since one <samp><span class="file">.class</span></samp> file would overwrite the
other.

<div class="node">
<a name="Exporting-Packages-or-Record-Types"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Exporting-Exceptions">Exporting Exceptions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragma-Export-Java">Pragma Export Java</a>

</div>

<h4 class="subsection">7.5.3 Exporting Packages or Record Types</h4>

<!-- ........................................................................... -->
<p class="noindent">NOTE: Exporting of packages is not yet supported. <br>

<p class="noindent">If the <var>Local_Name</var> of an <code>Export</code> pragma is the name of a package
spec or record type <var>P</var>, then the <var>String_Expression</var> of such an
<code>Export</code> pragma gives the name of the generated JVM class, overriding
the name that would have been given by the
compiler. <var>String_Expression</var> can be a simple class name, or it can
have the form <var>java_package_name</var><code>.</code><var>class_name</var> indicating
that the generated JVM class belongs to Java package
<var>java_package_name</var>. If <var>java_package_name</var> is missing, the JVM
class belongs to the anonymous Java package.

   <p>Care must be taken not to use the same class name for two Ada exceptions,
packages or record types when they belong to different source files located
in the same directory, since one <samp><span class="file">.class</span></samp> file would overwrite the
other.

   <p>If the same <code>Export</code> pragma is specified for a package spec and a
record type contained inside it, then the GNAT compiler will map both of
these in the same JVM class. For instance without <code>Export</code> pragmas the
following code generates 2 JVM <samp><span class="file">.class</span></samp> files:
<samp><span class="file">outer$child.class</span></samp> and <samp><span class="file">outer$child$rec.class</span></samp>.

<pre class="smallexample">     package Outer.Child is
        type Rec is tagged record
          F : Float;
        end record;
        procedure Proc (This : Rec);
        --  <i>This always goes in the same .class file as type</i> Rec
     
        function Global (I : Integer) return Rec;
        --  <i>This always goes in the same .class file as the package</i>
     end Outer.Child;
</pre>
   <p class="noindent">If the same <code>Export</code> pragma is used a single class file is generated
(<samp><span class="file">CHILD.class</span></samp> in JVM package <code>root.outer</code>).

<pre class="smallexample">     package Outer.Child is
        type Rec is record
          X : Float;
        end record;
        pragma Export (Java, Rec, "root.outer.CHILD");
     
        procedure Proc (This : Rec);
        function Global (I : Integer) return Rec;
        --  <i>Both subprograms are generated in the same .class file</i>
     end Outer.Child;
     pragma Export (Java, Outer.Child, "root.outer.CHILD");
</pre>
   <div class="node">
<a name="Mapping-Java-into-Ada"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Creating-Gnapplets-with-GNAT">Creating Gnapplets with GNAT</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Java_002dSpecific-Pragmas">Java-Specific Pragmas</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="chapter">8 Mapping Java into Ada</h2>

<!-- =========================================================================== -->
<p class="noindent">This chapter details the mapping used by <code>jvm2ada</code> to map Java
<samp><span class="file">.class</span></samp> files into Ada package specs. It is assumed that the reader
is familiar with the Java language.

<ul class="menu">
<li><a accesskey="1" href="#Identifiers">Identifiers</a>
<li><a accesskey="2" href="#Scalar-Types">Scalar Types</a>
<li><a accesskey="3" href="#Java-References-and-java_002elang_002eObject">Java References and java.lang.Object</a>
<li><a accesskey="4" href="#Array-Types">Array Types</a>
<li><a accesskey="5" href="#The-Ada-Package-Java">The Ada Package Java</a>
<li><a accesskey="6" href="#Use-of-Limited_002dWith-Clauses-by-jvm2ada">Use of Limited-With Clauses by jvm2ada</a>
<li><a accesskey="7" href="#Java-Packages">Java Packages</a>
<li><a accesskey="8" href="#Java-Classes">Java Classes</a>
<li><a accesskey="9" href="#Abstract-Classes">Abstract Classes</a>
<li><a href="#Final-Classes-and-Final-Methods">Final Classes and Final Methods</a>
<li><a href="#Nested-Classes">Nested Classes</a>
<li><a href="#Java-Interface">Java Interface</a>
<li><a href="#Java-Class-Implementing-Interfaces">Java Class Implementing Interfaces</a>
<li><a href="#Java-Exceptions">Java Exceptions</a>
<li><a href="#Static-Fields">Static Fields</a>
<li><a href="#Final-Static-Fields">Final Static Fields</a>
<li><a href="#Instance-Fields">Instance Fields</a>
<li><a href="#Volatile-and-Transient-Fields">Volatile and Transient Fields</a>
<li><a href="#Static-Methods">Static Methods</a>
<li><a href="#Instance-Methods">Instance Methods</a>
<li><a href="#Abstract-Methods">Abstract Methods</a>
<li><a href="#Native-Methods">Native Methods</a>
<li><a href="#Visibility-Issues">Visibility Issues</a>
<li><a href="#Java-Implicit-Upcasting-in-Ada">Java Implicit Upcasting in Ada</a>
<li><a href="#Mixing-Ada-Strings-and-Java-Strings">Mixing Ada Strings and Java Strings</a>
<li><a href="#An-Example">An Example</a>
</ul>

<div class="node">
<a name="Identifiers"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Scalar-Types">Scalar Types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.1 Identifiers</h3>

<!--  -->
<p class="noindent">See <a href="#Identifier-Mangling">Identifier Mangling</a>.

<div class="node">
<a name="Scalar-Types"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Java-References-and-java_002elang_002eObject">Java References and java.lang.Object</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Identifiers">Identifiers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.2 Scalar Types</h3>

<!--  -->
<p class="noindent">Java scalar tpes are mapped into Ada scalar types as follows:

<pre class="smallexample">               boolean <i>(1 byte)  maps into</i> Standard.Boolean
               char    <i>(2 bytes)  "    "  </i> Standard.Wide_Character
     
               byte    <i>(1 byte)   "    "  </i> Standard.Short_Short_Integer
               short   <i>(2 bytes)  "    "  </i> Standard.Short_Integer
               int     <i>(4 bytes)  "    "  </i> Standard.Integer
               long    <i>(8 bytes)  "    "  </i> Standard.Long_Integer
     
               float   <i>(4 bytes)  "    "  </i> Standard.Float
               double  <i>(8 bytes)  "    "  </i> Standard.Long_Float
</pre>
   <p class="noindent">As a convenience for the Ada programmer subtypes are used to express the
correspondence between primitive numeric Java types and the Ada scalar
types defined in package <code>Standard</code>.

   <p>We have chosen to place these subtypes at the root of the Ada version of
the Java API, i.e., in package <code>Java</code>. Thus these subtypes are directly
available in the Ada version of the API and at hand for users of the API. 
The code excerpt below gives the beginning of package
<code>java</code>:

<pre class="smallexample">     package java is
        pragma Preelaborate;
     
        subtype boolean is Standard.Boolean;
        subtype char    is Standard.Wide_Character;
        subtype byte    is Standard.Short_Short_Integer;
        subtype short   is Standard.Short_Integer;
        subtype int     is Standard.Integer;
        subtype long    is Standard.Long_Integer;
        subtype float   is Standard.Float;
        subtype double  is Standard.Long_Float;
        ...
     end java;
</pre>
   <div class="node">
<a name="Java-References-and-java.lang.Object"></a>
<a name="Java-References-and-java_002elang_002eObject"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Array-Types">Array Types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Scalar-Types">Scalar Types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.3 Java References and <code>java.lang.Object</code></h3>

<!--  -->
<p class="noindent">When it comes to composite objects such as arrays and records, Java differs
from Ada in the fact that it only has reference semantics. More precisely, in
Java you can only allocate an object in the garbage-collected heap and
obtain a reference to such object. All object reads and writes are done
via this reference.  In addition, you cannot copy an object as a whole into
another object: there is no default deep-copy operation in Java.

   <p>In mapping Java services to Ada, we have preserved its reference semantics,
as shown in the code excerpt below which shows the salient part of how
class <code>java.lang.Object</code> is mapped into Ada:

<pre class="smallexample">     package java.lang.Object is
        pragma Preelaborate;
     
        type Typ is tagged limited private;
        type Ref is access all Typ'Class;
     
        function new_Object (This : Ref := null) return Ref;
        --  <i>The constructor</i>
        ...
     private
     
        type Typ is tagged limited null record;
        ...
     end java.lang.Object;
</pre>
   <p class="noindent">As a first remark, tagged types imported from Java should be limited
since, as mentioned before, no object assignment operation exists on the JVM. 
Second, unlike Java, in Ada we need to define two types: one for the actual
tagged type (type <code>Typ</code>) and one for the actual refernces (type
<code>Ref</code>). This means that while in Java you can write something like:

<pre class="smallexample">     import java.lang.Object;
     class client {
        void foo () {
           Object obj = new Object ();
        }
     }
</pre>
   <p class="noindent">in Ada you have to write:

<pre class="smallexample">     with java.lang.Object; use java.lang.Object;
     procedure Foo is
        obj : Object.Ref = new_Object;
     begin
        null;
     end Foo;
</pre>
   <p class="noindent">Furthermore, for now we impose some restrictions on types that
extend types that are declared in packages imported from Java.

   <p>Since the parent type of such a type extension has convention Java,
the extended type inherits convention Java (even though declared
within a normal Ada package). This means that the extended type
should not contain any component declarations that would not
be appropriate in an equivalent Java class.

   <p>In particular, a type that extends from a Java-convention parent
type should not have any components of the following kinds:

     <ul>
<li>components with default initialization (excepting access components
that are initialized by null)
<li>components of composite types (arrays, records, tasks, protected types)
<li>components of private types whose full type is a composite type
</ul>

<p class="noindent">The reason for these restrictions is that each of the above formsu
of components requires some kind of run-time initialization at the
time an object of the containing type is created. Such initialization
needs to happen before any user code can reference the components. 
However, in the presence of user-defined constructors, which are
executed immediately after object creation (as required by the JVM),
this is difficult for the compiler to support.

   <p>The workaround for cases where composite components are desired
is instead to declare components of access types that designate the types
you want to use. The allocation and initialization of those access
components can then be performed as part of the actions of your own
user-defined constructor function (see <a href="#The-Java_005fConstructor-Pragma">The Java_Constructor Pragma</a>).

   <p>If we were to allow such components, the consequences of failing to
heed the above restrictions would include the creation of objects
that are not fully allocated or initialized, with the potential
for crashing the program.

   <p>The GNAT compiler will reject the attempt to declare a Java-convention
record type with any of the restricted forms of components by flagging
each offending component. We plan to try relaxing these restrictions
in a future release.

<div class="node">
<a name="Array-Types"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-Ada-Package-Java">The Ada Package Java</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Java-References-and-java_002elang_002eObject">Java References and java.lang.Object</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.4 Array Types</h3>

<!--  -->
<p class="noindent">Let's illustrate the mapping with an example. Assume you would like to map
a Java array of <code>int</code> into Ada. For instance, in Java you might write:

<pre class="smallexample">     int[] obj;
     //  obj <i>is a reference to an array of int</i>
     
     obj = new int [3];
     //  <i>Allocate an array-of-int object with 3 elements.</i>
     //  <i>The index of the first element is zero.</i>
</pre>
   <p class="noindent">The above is mapped into the following Ada declarations:

<pre class="smallexample">     type int_Arr_Obj is array (Natural range &lt;&gt;) of int;
     type int_Arr     is access all int_Arr_Obj;
     
     obj : int_Arr;
     --  int[] obj;
     
     obj := new int_Array_Obj (0 .. 2);
     --  obj = new int [3];
</pre>
   <p class="noindent">Java does not have multidimensional arrays, it only has arrays of arrays. As
a result

<pre class="smallexample">     int[][] obj2 = new int [3][2];
</pre>
   <p class="noindent">is mapped into

<pre class="smallexample">     type int_Arr_2_Obj is array (Natural range &lt;&gt;) of int_Arr;
     type int_Arr_2     is access all int_Arr_2_Obj;
     
     Obj2 : int_Arr_2 := new int_Arr_2_Obj (0 .. 2, 0 .. 1);
     --  obj2 = new int [3][2];
</pre>
   <p class="noindent">The final question that remains to answer is where are the various array type
definitions located. Scalar array types have been placed in
package <code>Java</code>, while array types associated with a given JVM class are
placed in the Ada package spec for that class. Indeed
when processing a JVM class <var>C</var>, <code>jvm2ada</code> generates the
following at the beginning of the Ada package spec coresponding to <var>C</var>:

<pre class="smallexample">     package <var>C</var> is
        pragma Preelaborate;
     
        type Typ is ...;
        type Ref is access all Typ'Class;
     
        type Arr_Obj is array (Natural range &lt;&gt;) of Ref;
        type Arr     is access all Arr_Obj;
     
        type Arr_2_Obj is array (Natural range &lt;&gt;) of Arr;
        type Arr_2     is access all Arr_2_Obj;
     
        ...
     end <var>C</var>;
</pre>
   <div class="node">
<a name="The-Ada-Package-Java"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Use-of-Limited_002dWith-Clauses-by-jvm2ada">Use of Limited-With Clauses by jvm2ada</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Array-Types">Array Types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.5 The Ada Package <code>Java</code></h3>

<!--  -->
<pre class="smallexample">     package java is
        pragma Preelaborate;
     
        subtype boolean is Standard.Boolean;
        subtype char    is Standard.Wide_Character;
        subtype byte    is Standard.Short_Short_Integer;
        subtype short   is Standard.Short_Integer;
        subtype int     is Standard.Integer;
        subtype long    is Standard.Long_Integer;
        subtype float   is Standard.Float;
        subtype double  is Standard.Long_Float;
     
        --  <i>boolean array types:</i> boolean [], boolean [][], boolean [][][]
     
        type boolean_Arr_Obj   is array (Natural range &lt;&gt;) of boolean;
        type boolean_Arr       is access all boolean_Arr_Obj;
     
        type boolean_Arr_2_Obj is array (Natural range &lt;&gt;) of boolean_Arr;
        type boolean_Arr_2     is access all boolean_Arr_2_Obj;
     
        type boolean_Arr_3_Obj is array (Natural range &lt;&gt;) of boolean_Arr_2;
        type boolean_Arr_3     is access all boolean_Arr_3_Obj;
     
        --  <i>char array types:</i> char [], char [][], char [][][]
     
        type char_Arr_Obj   is array (Natural range &lt;&gt;) of char;
        type char_Arr       is access all char_Arr_Obj;
     
        type char_Arr_2_Obj is array (Natural range &lt;&gt;) of char_Arr;
        type char_Arr_2     is access all char_Arr_2_Obj;
     
        type char_Arr_3_Obj is array (Natural range &lt;&gt;) of char_Arr_2;
        type char_Arr_3     is access all char_Arr_3_Obj;
     
        --  <i>byte array types:</i> byte [], byte [][], byte [][][]
     
        type byte_Arr_Obj   is array (Natural range &lt;&gt;) of byte;
        type byte_Arr       is access all byte_Arr_Obj;
     
        type byte_Arr_2_Obj is array (Natural range &lt;&gt;) of byte_Arr;
        type byte_Arr_2     is access all byte_Arr_2_Obj;
     
        type byte_Arr_3_Obj is array (Natural range &lt;&gt;) of byte_Arr_2;
        type byte_Arr_3     is access all byte_Arr_3_Obj;
     
        --  <i>short array types:</i> short [], short [][], short [][][]
     
        type short_Arr_Obj   is array (Natural range &lt;&gt;) of short;
        type short_Arr       is access all short_Arr_Obj;
     
        type short_Arr_2_Obj is array (Natural range &lt;&gt;) of short_Arr;
        type short_Arr_2     is access all short_Arr_2_Obj;
     
        type short_Arr_3_Obj is array (Natural range &lt;&gt;) of short_Arr_2;
        type short_Arr_3     is access all short_Arr_3_Obj;
     
        --  <i>int array types:</i> int [], int [][], int [][][]
     
        type int_Arr_Obj   is array (Natural range &lt;&gt;) of int;
        type int_Arr       is access all int_Arr_Obj;
     
        type int_Arr_2_Obj is array (Natural range &lt;&gt;) of int_Arr;
        type int_Arr_2     is access all int_Arr_2_Obj;
     
        type int_Arr_3_Obj is array (Natural range &lt;&gt;) of int_Arr_2;
        type int_Arr_3     is access all int_Arr_3_Obj;
     
        --  <i>long array types:</i> long [], long [][], long [][][]
     
        type long_Arr_Obj   is array (Natural range &lt;&gt;) of long;
        type long_Arr       is access all long_Arr_Obj;
     
        type long_Arr_2_Obj is array (Natural range &lt;&gt;) of long_Arr;
        type long_Arr_2     is access all long_Arr_2_Obj;
     
        type long_Arr_3_Obj is array (Natural range &lt;&gt;) of long_Arr_2;
        type long_Arr_3     is access all long_Arr_3_Obj;
     
        --  <i>float array types:</i> float [], float [][], float [][][]
     
        type float_Arr_Obj   is array (Natural range &lt;&gt;) of float;
        type float_Arr       is access all float_Arr_Obj;
     
        type float_Arr_2_Obj is array (Natural range &lt;&gt;) of float_Arr;
        type float_Arr_2     is access all float_Arr_2_Obj;
     
        type float_Arr_3_Obj is array (Natural range &lt;&gt;) of float_Arr_2;
        type float_Arr_3     is access all float_Arr_3_Obj;
     
        --  <i>double array types:</i> double [], double [][], double [][][]
     
        type double_Arr_Obj   is array (Natural range &lt;&gt;) of double;
        type double_Arr       is access all double_Arr_Obj;
     
        type double_Arr_2_Obj is array (Natural range &lt;&gt;) of double_Arr;
        type double_Arr_2     is access all double_Arr_2_Obj;
     
        type double_Arr_3_Obj is array (Natural range &lt;&gt;) of double_Arr_2;
        type double_Arr_3     is access all double_Arr_3_Obj;
     
     end java;
</pre>
<div class="node">
<a name="Use-of-Limited-With-Clauses-by-jvm2ada"></a>
<a name="Use-of-Limited_002dWith-Clauses-by-jvm2ada"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Java-Packages">Java Packages</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-Ada-Package-Java">The Ada Package Java</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.6 Use of Limited-With Clauses by <code>jvm2ada</code></h3>

<!-- .......................................................................... -->
<p class="noindent">Consider the following

<pre class="smallexample">     public class C extends B implements I {
        public D link;
        ...
     }
</pre>
   <p class="noindent">When <code>jvm2ada</code> is invoked to process <samp><span class="file">C.class</span></samp> to create an Ada
spec for <code>C</code>, it is difficult to know whether reference type <code>D</code>
is involved in a circular dependency with class <code>C</code>. First of all,
<code>D.class</code> may not even be available yet.  Even if it were, classes
<code>C</code> and <code>D</code> could be involved in a complex circular relationship
with other classes, some of which may not be available. In addition, in the
presence of circular dependencies there is no good reason for using a
<code>with type</code> clause in one package spec and a regular <code>with</code> clause
in another.

   <p>There are three cases in which a class <code>C</code> refers to another class
<var>X</var>:

     <ol type=1 start=1>
<li><code>C</code> extends <var>X</var>.

     <li><code>C</code> implements <var>X</var>.

     <li><var>X</var> is used as a reference (e.g., a reference to an object or array of
objects of type <var>X</var>).
        </ol>

<p class="noindent">In the first case, the Ada package spec corresponding to <code>C</code> needs to
have a regular <code>with</code> clause for the package spec corresponding to
<var>X</var>.  In all other cases a <code>with type</code> clause suffices.

   <p>As a result, <code>jvm2ada</code> will generate the following <code>with</code> and
<code>limited with</code> clauses for the class <code>C</code> above:

<pre class="smallexample">     with B;
     limited with I;
     limited with D;
</pre>
   <div class="node">
<a name="Java-Packages"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Java-Classes">Java Classes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Use-of-Limited_002dWith-Clauses-by-jvm2ada">Use of Limited-With Clauses by jvm2ada</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.7 Java Packages</h3>

<!--  -->
<p class="noindent">A Java package <var>pack</var> is mapped into an empty Ada package spec
<var>pack</var>.  For instance, Java package <code>java.lang</code> is mapped into the
following Ada spec:

<pre class="smallexample">     package java.lang is
        pragma Preelaborate;
     end java.lang;
</pre>
   <div class="node">
<a name="Java-Classes"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Abstract-Classes">Abstract Classes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Java-Packages">Java Packages</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.8 Java Classes</h3>

<!--  -->
<p class="noindent">A Java class <var>X.Y.D</var> extending a class <var>W.Z.B</var> is mapped into an Ada
package <var>X.Y.D</var> containing a tagged type definition <code>Typ</code> that
extends <var>W.Z.B</var><code>.Typ</code> and a reference type definition <code>Ref</code> as
shown below:

<pre class="smallexample">     with Java; use Java;
     
     package <var>X.Y.D</var> is
        pragma Preelaborate;
     
        -----------------------
        -- Type Declarations --
        -----------------------
     
        type Typ;
        type Ref is access all Typ'Class;
     
        --  <i>Array type declarations for X.Y.D</i>
     
        type Arr_Obj is array (Natural range &lt;&gt;) of Ref;
        type Arr     is access all Arr_Obj;
     
        type Arr_2_Obj is array (Natural range &lt;&gt;) of Arr;
        type Arr_2     is access all Arr_2_Obj;
     
        type Arr_3_Obj is array (Natural range &lt;&gt;) of Arr_2;
        type Arr_3     is access all Arr_3_Obj;
     
        --  <i>The actual type declaration for X.Y.D</i>
     
        type Typ is new <var>W.Z.B</var>.Typ
           with record
     
              ------------------------
              -- Field Declarations --
              ------------------------
              ...
           end record;
     
        ------------------------------
        -- Constructor Declarations --
        ------------------------------
        ...
     
        -------------------------
        -- Method Declarations --
        -------------------------
        ...
     
        ---------------------------
        -- Variable Declarations --
        ---------------------------
        ...
     
     private
        pragma Convention (Java, Typ);
        ...  --  <i>other pragmas are generated here</i>
     end <var>X.Y.D</var>;
     pragma Import (Java, <var>X.Y.D</var>, "<var>W.Z.B</var>");
</pre>
   <p class="noindent">In addition, all of the static variables of <var>X.Y.D</var> are mapped
into variables of the Ada package and all static methods of <var>X.Y.D</var> are
mapped into nondispatching subprograms in the Ada package.

   <p>Each instance method of class <var>X.Y.D</var> is converted into a primitive
operation of type <var>X.Y.D</var><code>.Typ</code> whose first parameter is of type
&ldquo;<code>access Typ</code>&rdquo; and whose remaining parameters are as in the Java
class.

   <p>Constructors in class <var>X.Y.D</var> are mapped into subprograms in package
<var>X.Y.D</var> as described in a previous section (see <a href="#The-Java_005fConstructor-Pragma">The Java_Constructor Pragma</a>).

<div class="node">
<a name="Abstract-Classes"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Nested-Classes">Nested Classes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Java-Classes">Java Classes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.9 Abstract Classes</h3>

<!--  -->
<p class="noindent">Java's abstract classes are exactly equivalent to Ada's abstract tagged
types and are mapped into such types by <code>jvm2ada</code>.

<div class="node">
<a name="Nested-Classes"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Java-Interface">Java Interface</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Abstract-Classes">Abstract Classes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.10 Nested Classes</h3>

<!--  -->
<p class="noindent">A class <code>Inner</code> nested inside a class <code>Outer</code> is mapped into
a child package named <br>
<code>Outer.Inner</code>.

<div class="node">
<a name="Java-Interface"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Java-Class-Implementing-Interfaces">Java Class Implementing Interfaces</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Nested-Classes">Nested Classes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.11 Java Interface</h3>

<!--  -->
<p class="noindent">See <a href="#Creating-Java-Interfaces-with-Pragma-Java_005fInterface">Creating Java Interfaces with Pragma Java_Interface</a>.

<div class="node">
<a name="Java-Class-Implementing-Interfaces"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Java-Exceptions">Java Exceptions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Java-Interface">Java Interface</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.12 Java Class Implementing Interfaces</h3>

<!--  -->
<p class="noindent">See <a href="#Using-Java-Interfaces">Using Java Interfaces</a>.

<div class="node">
<a name="Java-Exceptions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Static-Fields">Static Fields</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Java-Class-Implementing-Interfaces">Java Class Implementing Interfaces</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.13 Java Exceptions</h3>

<!--  -->
<p class="noindent">When processing a JVM class, <code>jvm2ada</code> must figure out whether this
class is a Java exception, i.e. whether it derives, directly or
indirectly from class <code>java.lang.Throwable</code>.

   <p>To determine this, <code>jvm2ada</code> traverses the inheritance tree and
must locate the <samp><span class="file">.class</span></samp> files of the ancestor classes
(see <a href="#Class-File-Search-Paths">Class File Search Paths</a>). If the class is indeed a Java
exception, an Ada exception is added to the generated Ada spec as shown
in the following example:

<pre class="smallexample">     package pack1.pack2;
     public class C extends java.lang.Throwable { ... }
</pre>
   <p class="noindent">is mapped into

<pre class="smallexample">     package pack1.pack2.C is
        ...
        Except : Exception;
        ...
     end pack1.pack2.C;
</pre>
   <div class="node">
<a name="Static-Fields"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Final-Static-Fields">Final Static Fields</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Java-Exceptions">Java Exceptions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.14 Static Fields</h3>

<!--  -->
<p class="noindent">A static field in Java is equivalent to a regular variable in Ada and is
mapped accordingly by <code>jvm2ada</code>.

<div class="node">
<a name="Final-Static-Fields"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Instance-Fields">Instance Fields</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Static-Fields">Static Fields</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.15 Final Static Fields</h3>

<!--  -->
<p class="noindent">A Java <code>final</code> static field is equivalent to an Ada constant. 
When importing a final static field from Java, <code>jvm2ada</code>
maps each such field to an Ada deferred constant with an associated
pragma <code>Import</code> Java.

<div class="node">
<a name="Instance-Fields"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Volatile-and-Transient-Fields">Volatile and Transient Fields</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Final-Static-Fields">Final Static Fields</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.16 Instance Fields</h3>

<!--  -->
<p class="noindent">An instance field is mapped by <code>jvm2ada</code> into a field of its corresponding
tagged type.

<div class="node">
<a name="Volatile-and-Transient-Fields"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Static-Methods">Static Methods</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Instance-Fields">Instance Fields</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.17 Volatile and Transient Fields</h3>

<!--  -->
<p class="noindent">The JVM <code>volatile</code> and <code>transient</code> attributes are currently ignored
by <code>jvm2ada</code>.

<div class="node">
<a name="Static-Methods"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Instance-Methods">Instance Methods</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Volatile-and-Transient-Fields">Volatile and Transient Fields</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.18 Static Methods</h3>

<!--  -->
<p class="noindent">A Java static method is equivalent to a regular nondispatching subprogram
in Ada and is mapped that way by <code>jvm2ada</code>.

<div class="node">
<a name="Instance-Methods"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Abstract-Methods">Abstract Methods</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Static-Methods">Static Methods</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.19 Instance Methods</h3>

<!--  -->
<p class="noindent">Each instance method is converted into a primitive operation whose first
parameter is of type &ldquo;<code>access Typ</code>&rdquo; and whose remaining parameters are
as given for the Java method.

<div class="node">
<a name="Abstract-Methods"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Native-Methods">Native Methods</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Instance-Methods">Instance Methods</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.20 Abstract Methods</h3>

<!--  -->
<p class="noindent">Java's abstract methods are exactly equivalent to Ada's abstract
primitive operations and are mapped accordingly by <code>jvm2ada</code>.

<div class="node">
<a name="Native-Methods"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Final-Classes-and-Final-Methods">Final Classes and Final Methods</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Abstract-Methods">Abstract Methods</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.21 Native Methods</h3>

<!--  -->
<p class="noindent">In Java one can assert that a certain method is <code>native</code>, i.e., that
its implementation is provided in some native language such as C or Ada,
external to the JVM.  The <code>jvm2ada</code> tool ignores the <code>native</code>
attribute when mapping JVM methods into Ada, since JVM methods are invoked
in exactly the same way regardless of whether they have a <code>native</code>
attribute.

<div class="node">
<a name="Final-Classes-and-Final-Methods"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Visibility-Issues">Visibility Issues</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Native-Methods">Native Methods</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.22 Final Classes and Final Methods</h3>

<!--  -->
<p class="noindent">Java has a way to restrict further derivation from a class type or further
overriding of a primitive operation. For instance, given

<pre class="smallexample">     public class Base { ... }
     public final class Deriv extends Base { ... }
</pre>
   <p class="noindent">it is possible to create subclasses of <code>Base</code> but not of
<code>Deriv</code>, since <code>Deriv</code> is marked <code>final</code>. Likewise, given

<pre class="example">     public class Base {
        public       int service_1 () { ... }
        public final int service_2 () { ... }
     }
</pre>
   <p class="noindent">it is possible to override method <code>service_1</code> in every
subclass of <code>Base</code>, whereas <code>service_2</code> cannot be overriden.

   <p>Limiting type derivation and primitive operation overriding is not directly
possible in Ada. We have therefore chosen for the time being to ignore
<code>final</code> classes and methods (a comment is emitted before them but nothing
more). If a Java final class is extended or a final method overridden in Ada,
an exception (or verifier error) will be emitted at execution time.

<div class="node">
<a name="Visibility-Issues"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Java-Implicit-Upcasting-in-Ada">Java Implicit Upcasting in Ada</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Final-Classes-and-Final-Methods">Final Classes and Final Methods</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.23 Visibility Issues</h3>

<!--  -->
     <ul>
<li>A <code>public</code> Java class is mapped into a public Ada package spec.

     <li>A non-public Java class containing <code>public</code> nested classes is
mapped into an empty Ada package (much in the same way Java packages are
mapped into Ada packages). This ensures that the parent Ada package is
defined for the child classes.

     <li>A <code>public</code> Java member is mapped into an entity declared in the public
part of the corresponding Ada package if all of its parameter and return
types refer to a public Java class.

     <li>A <code>protected</code> Java member is mapped into an entity declared in the
public part of the corresponding Ada package and treated like a <code>public</code>
Java member as described in the above bullet point. Because in Ada there is
no concept similar to the <code>protected</code> qualifier in Java, if you use a
protected entity from Ada in a way that is forbidden by the JVM a run-time
exception will occur.

     <li>A <code>private</code> Java member corresponds to an Ada entity declared in a
package body. <code>jvm2ada</code> ignores all such entities.

     <li>Java entities declared as non-public (i.e. with no Java access qualifiers)
are visible only to Java classes belonging to the same Java package and are
intended to be accessed only from classes in the same API as <code>C</code>. 
<code>jvm2ada</code> ignores all such entities. 
</ul>

<div class="node">
<a name="Java-Implicit-Upcasting-in-Ada"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Mixing-Ada-Strings-and-Java-Strings">Mixing Ada Strings and Java Strings</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Visibility-Issues">Visibility Issues</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.24 Java Implicit Upcasting in Ada</h3>

<!--  -->
<p class="noindent">Given the following two class definitions:

<pre class="smallexample">     public class Base {
        public static void proc (Base p, Base q) {...}
     }
     public class Derived extends Base {...}
</pre>
   <p class="noindent">Java allows the following code to be written (and Java programmers
take advantage of the following):

<pre class="smallexample">     Base    obj1 = new Base ();
     Derived obj2 = new Derived ();
     proc (obj1, obj2);
</pre>
   <p class="noindent">The implicit conversion from the pointer to the <code>Derived</code> type to the
<code>Base</code> type is completely safe and is allowed in Java much as Ada allows
implicit conversion between similar anonymous access types (in Java when you
write "<code>Derived obj2</code>" you are really saying that <code>obj2</code> is a
pointer to an object of type <code>Derived</code> whose pointer type is anonymous). 
If <code>jvm2ada</code> mapped class Base into:

<pre class="smallexample">     package Base is
        type Typ;
        type Ref is access all Typ'class;
        ...
        procedure proc (P1 : Base.Ref; P2 : Base.Ref);
        ...
     end Base;
</pre>
   <p class="noindent">The call to <code>proc</code> in Ada would have to look like

<pre class="smallexample">        obj1 : Base.Ref    := new_Base;
        obj2 : Derived.Ref := new_Derived;
        proc (obj1, Base.Ref (obj2));
</pre>
   <p class="noindent">which is verbose (especially when using real class names) without any
fundamental reason (writing "<code>proc (obj1, obj2.all'access)</code>" would
hardly be any terser). To address this inconvenience we have used access
parameters when generating the Ada equivalent to <code>proc</code>:

<pre class="smallexample">     procedure proc (P1 : access Base.Typ'Class;
                     P2 : access Base.Typ'Class);
</pre>
   <p class="noindent">allowing us to write:

<pre class="smallexample">        obj1 : Base.Ref    := new_Base;
        obj2 : Derived.Ref := new_Derived;
        proc (obj1, obj2);
</pre>
   <p class="noindent">The observant reader will notice that this new mapping into Ada of procedure
<code>proc</code> is not equivalent to the first one since in the case of access
parameters Ada checks that the parameters are not <code>null</code> (and an
exception will be raised if they are).

   <p>This problem is worked around by disabling the <code>null</code>
access check in package specs imported from Java. Note that this is a
temporary expedient until a solution to this problem is agreed upon by
the ISO WG9-sponsored Ada Rapporteur Group (ARG).

<div class="node">
<a name="Mixing-Ada-Strings-and-Java-Strings"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#An-Example">An Example</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Java-Implicit-Upcasting-in-Ada">Java Implicit Upcasting in Ada</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.25 Mixing Ada Strings and Java Strings</h3>

<!--  -->
<p class="noindent">To facilitate the use of regular Ada strings in Java routines we have added
the following type definition and subprograms to the body of package
<code>java.lang.String</code> generated by <code>jvm2ada</code>:

<pre class="smallexample">     ---------------------------------------------------
     -- Java String to Ada String Conversion Routines --
     ---------------------------------------------------
     
     type String_Access is access all Standard.String;
     function "+" (S : java.lang.String.Ref) return String_Access;
     function "+" (S : Standard.String) return java.lang.String.Ref;
     
</pre>
   <p class="noindent">With the above you can write:

<pre class="smallexample">     
     procedure P (JS : java.lang.String.Ref);
     function  F return java.lang.String.Ref;
     
     S_Ptr String_Access := +F;
     P (+"hello GNAT for the JVM");
</pre>
   <div class="node">
<a name="An-Example"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Mixing-Ada-Strings-and-Java-Strings">Mixing Ada Strings and Java Strings</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>

</div>

<h3 class="section">8.26 An Example</h3>

<!--  -->
<p class="noindent">As an example consider the following Java class

<pre class="smallexample">     package A.B;
     
     public class Foo
       extends    java.awt.event.ComponentAdapter
       implements java.io.Serializable
     {
        //  Instance Variables
     
        public int   i_Field;
        public float f_Filed;
     
        //  Constructors
     
        public Foo () {}
        public Foo (java.lang.String s) {}
     
        //  Instance Methods
     
        public void first_op  (java.lang.Thread t) {}
        public int  second_op () {return 1;}
     
        //  Static Variables
     
        public static int   i_Var;
        public static float f_Var;
     
        //  Static Methods
     
        public static void proc  (Foo obj, int [] b) {}
        public static int  funct (Foo [][] a, int l, int h) {return 1;}
     }
</pre>
   <p class="noindent">After processing this class using the following <code>jvm2ada</code> command
(<var>java-dir</var> is the location of Sun's JDK 1.2 installation):

<pre class="smallexample">     jvm2ada -L<var>java-dir</var>/jdk1.2.2/jre/lib/rt.jar Foo.class
</pre>
   <p class="noindent">we obtain the following Ada spec (comments in italics have been added for
explanatory purposes):

<pre class="smallexample">     with Java; use Java;
     with java.awt.event.ComponentAdapter;
     with type java.awt.event.ComponentListener.Ref is access;
     with type java.io.Serializable.Ref is access;
     with type java.lang.String.Typ is tagged;
     with type java.lang.Thread.Typ is tagged;
     
     package A.B.Foo is
        pragma Preelaborate;
     
        -----------------------
        -- Type Declarations --
        -----------------------
     
        type Typ;
        type Ref is access all Typ'Class;
     
        type Arr_Obj is array (Natural range &lt;&gt;) of Ref;
        type Arr     is access all Arr_Obj;
     
        type Arr_2_Obj is array (Natural range &lt;&gt;) of Arr;
        type Arr_2     is access all Arr_2_Obj;
     
        type Arr_3_Obj is array (Natural range &lt;&gt;) of Arr_2;
        type Arr_3     is access all Arr_3_Obj;
     
        type Typ
           (ComponentListener_I : java.awt.event.ComponentListener.Ref;
           --  <i>In the Ada mapping all implemented interfaces must appear</i>
           --  <i>in the list of discriminants. The discriminats corresponding</i>
           --  <i>to those inherited from the parent type (in this case</i>
           --  Component_Listener<i>) must be used to constrain the parent</i>
           --  <i>type in the Ada tagged type definition.</i>
           Serializable_I : java.io.Serializable.Ref)
           is new
              java.awt.event.ComponentAdapter.Typ (ComponentListener_I)
           with record
     
              ------------------------
              -- Field Declarations --
              ------------------------
     
              i_Field : java.Int;
              pragma Import (Java, i_Field, "i_Field");
     
              f_Filed : java.Float;
              pragma Import (Java, f_Filed, "f_Filed");
     
           end record;
     
        ------------------------------
        -- Constructor Declarations --
        ------------------------------
     
        function new_Foo (This : Ref := null)
                          return Ref;
     
        function new_Foo (P1 : access java.lang.String.Typ'Class;
                          This : Ref := null)
                          return Ref;
     
        -------------------------
        -- Method Declarations --
        -------------------------
     
        procedure first_op (This : access Typ;
                            P1 : access java.lang.Thread.Typ'Class);
     
        function funct (P1 : A.B.Foo.Arr_2;
                        P2 : java.Int;
                        P3 : java.Int)
                        return java.Int;
     
        procedure proc (P1 : access A.B.Foo.Typ'Class;
                        P2 : java.Int_Arr);
     
        function second_op (This : access Typ)
                            return java.Int;
     
        ---------------------------
        -- Variable Declarations --
        ---------------------------
     
        i_Var : Java.Int;
        f_Var : Java.Float;
     
     private
     
        pragma Convention (Java, Typ);
        pragma Java_Constructor (new_Foo);
        pragma Import (Java, first_op, "first_op");
        pragma Import (Java, funct, "funct");
        pragma Import (Java, proc, "proc");
        pragma Import (Java, second_op, "second_op");
        pragma Import (Java, i_Var, "i_Var");
        pragma Import (Java, f_Var, "f_Var");
     
     end A.B.Foo;
     pragma Import (Java, A.B.Foo, "A.B.Foo");
     
</pre>
   <p class="noindent">The following code shows you how to use <code>Foo</code>'s services in your code.

<pre class="smallexample">     
     with java.lang.String; use java.lang.String;
     with A.B.Foo; use A.B.Foo;
     use A.B;
     use Java;
     
     procedure Client is
        O  : Foo.Ref      := new_Foo (+"hello there");
        AO : Foo.Arr_2    :=
           new Foo.Arr_2_Obj'
                  (0..9 =&gt;
                     new Foo.Arr_Obj' (0..3 =&gt; new_Foo));
     
        I  : int          := funct (AO, AO'Last, 7);
        AI : Java.Int_Arr := new Java.Int_Arr_Obj (0..5);
     
     begin
        proc (O, AI);
     end Client;
</pre>
   <div class="node">
<a name="Creating-Gnapplets-with-GNAT"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Debugging-Ada-Programs">Debugging Ada Programs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Mapping-Java-into-Ada">Mapping Java into Ada</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="chapter">9 Creating Gnapplets with GNAT</h2>

<!-- =========================================================================== -->
<p class="noindent">This chapter explains how you can use GNAT to create
a &ldquo;gnapplet&rdquo; (GNAT applet).

<ul class="menu">
<li><a accesskey="1" href="#Extending-java_002eapplet_002eApplet_002eTyp">Extending java.applet.Applet.Typ</a>
<li><a accesskey="2" href="#Initializing-and-Finalizing-the-GNAT-Runtime">Initializing and Finalizing the GNAT Runtime</a>
<li><a accesskey="3" href="#Compiling-the-Gnapplet">Compiling the Gnapplet</a>
<li><a accesskey="4" href="#Creating-the-HTML-file">Creating the HTML file</a>
</ul>

<p class="noindent">The examples provided with your GNAT installation contain a couple of
gnapplet examples. This chapter explains the steps that you need to take
to create your own gnapplets.

<div class="node">
<a name="Extending-java.applet.Applet.Typ"></a>
<a name="Extending-java_002eapplet_002eApplet_002eTyp"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Initializing-and-Finalizing-the-GNAT-Runtime">Initializing and Finalizing the GNAT Runtime</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Creating-Gnapplets-with-GNAT">Creating Gnapplets with GNAT</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Creating-Gnapplets-with-GNAT">Creating Gnapplets with GNAT</a>

</div>

<h3 class="section">9.1 Extending <code>java.applet.Applet.Typ</code></h3>

<!--  -->
<p class="noindent">The first thing you need to do to create an applet is to extend
<code>java.Applet.Applet.Typ</code> as shown in the followng example:

<pre class="smallexample">     with java; use java;
     with java.applet.Applet;
     with java.awt.Graphics;
     
     package Animate is
        --  Typ <i>implements the same interfaces as Applet.Typ and no</i>
        --  <i>new interfaces, so we do not need to add discriminants to the</i>
        --  <i>type definition below.</i>
     
        type Typ is new java.applet.Applet.Typ with record
           Count : Integer;
        end record;
        type Ref is access all Typ'Class;
     
        procedure Init    (This : access Typ);
        procedure Start   (This : access Typ);
        procedure Stop    (This : access Typ);
        procedure Destroy (This : access Typ);
     
     private
        pragma Convention (Java, Typ);
     end Animate;
</pre>
   <p class="noindent">In addition to extending <code>java.applet.Applet.Typ</code>, some functions from <br>
<code>java.applet.Applet</code> need to be overridden, namely:

<pre class="smallexample">        procedure Init (This : access Typ);
        --  <i>This function is called the first time the JVM initializes the</i>
        --  <i>the applet. This is where you should put your own initializations</i>
        --  <i>as well as the call to the elaboration code for the Ada runtime</i>
        --  <i>library, as shown in the next section.</i>
     
        procedure Start (This : access Typ):
        procedure Stop  (This : access Typ);
        --  <i>These routines are called when your applet starts or stops</i>
        --  <i>running (e.g., when it becomes visible to the user,</i>
        --  <i>or when the user moves to another page)</i>
     
        procedure Destroy (This : access Typ);
        --  <i>Called by the browser or applet viewer to inform this applet</i>
        --  <i>that it is being reclaimed and that it should destroy any</i>
        --  <i>resources that it has allocated. The</i> stop <i>method will always</i>
        --  <i>be called before</i> destroy.
        --  <i>A subclass of</i> Applet <i>should override this method if it has</i>
        --  <i>any operation that it wants to perform before it is destroyed.</i>
</pre>
   <p class="noindent">In addition you may want to override the following two methods:

<pre class="smallexample">       procedure Paint (This     : access Typ;
                        Graphics : access Java.Awt.Graphics.Typ'Class);
       --  <i>Called every time the applet needs to be repainted.</i>
       --  <i>Every drawing should be done on Graphics. See the Java API</i>
       --  <i>documentation for more info.</i>
     
       procedure Update (This : access Typ;
                         G    : access java.awt.Graphics.Typ'Class);
       --  <i>The AWT calls this method in response to a call to</i>
       --  repaintupdate <i>or</i> paint. <i>See the Java API</i>
       --  <i>documentation for more info.</i>
</pre>
   <div class="node">
<a name="Initializing-and-Finalizing-the-GNAT-Runtime"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Compiling-the-Gnapplet">Compiling the Gnapplet</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Extending-java_002eapplet_002eApplet_002eTyp">Extending java.applet.Applet.Typ</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Creating-Gnapplets-with-GNAT">Creating Gnapplets with GNAT</a>

</div>

<h3 class="section">9.2 Initializing and Finalizing the GNAT Runtime</h3>

<!--  -->
<p class="noindent">When writing the code for your gnapplet you must remeber to initialize
the GNAT runtime upon startup of your applet. You must also remember to
finalize the GNAT runtime upon destruction of your applet. This is easy
to do: you just need to call the routine <code>Adainit</code> in method
<code>Init</code> and the routine <code>Adafinal</code> in method <code>Destroy</code>. 
As usual <code>Adainit</code> and <code>Adafinal</code> have been generated by
<code>jvm-gnatbind</code> if switch <code>-n</code> is selected.

   <p>The only additional thing you need to know is the name of the class file
where <code>jvm-gnatbind</code> generates these routines. The name of this class
file is <code>ada_</code><var>gnapplet-name</var>, where <var>gnapplet-name</var> is the
name of the gnapplet package where <code>java.applet.Applet.Typ</code> was
derived.

   <p>As an example here is the body of methods <code>Init</code> and <code>Destroy</code>
of the <code>Animate</code> gnapplet example given in the previous section:

<pre class="smallexample">     package body Animate is
        ...
        procedure Init (This : access Typ) is
           procedure Adainit;
           pragma Import (Ada, Adainit, "ada_animate.adainit");
        begin
           Adainit;
           --  <i>other initializations go here, after the call to</i> Adainit
        end Init;
     
        procedure Destroy (This : access Typ) is
           procedure Adafinal;
           pragma Import (Ada, Adafinal, "ada_animate.adafinal");
        begin
           --  <i>other finalizations go here, before the call to</i> Adafinal
           Adafinal;
        end Destroy;
        ...
     end Animate
</pre>
   <div class="node">
<a name="Compiling-the-Gnapplet"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Creating-the-HTML-file">Creating the HTML file</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Initializing-and-Finalizing-the-GNAT-Runtime">Initializing and Finalizing the GNAT Runtime</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Creating-Gnapplets-with-GNAT">Creating Gnapplets with GNAT</a>

</div>

<h3 class="section">9.3 Compiling the Gnapplet</h3>

<!--  -->
<p class="noindent">Once you have written your gnapplet, you need to compile it.  This is done in
the usual fashion, except for the fact that because there is no main
program you need to call the binder and the linker by hand. As an example, to
compile the gnapplet given in package <code>Animate</code> given in the previous
example you can type:

<pre class="smallexample">         $ jvm-gnatmake animate
         $ jvm-gnatbind -n animate.ali
         $ jvm-gnatlink animate.ali
         $ jarmake -o animate.jar animate$typ.class
</pre>
   <p class="noindent">The <code>jarmake</code> command is particularly important for packaging all the
<samp><span class="file">.class</span></samp> files needed by your gnapplet in a single zip archive.

<div class="node">
<a name="Creating-the-HTML-file"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Compiling-the-Gnapplet">Compiling the Gnapplet</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Creating-Gnapplets-with-GNAT">Creating Gnapplets with GNAT</a>

</div>

<h3 class="section">9.4 Creating the HTML file</h3>

<!--  -->
<p class="noindent">The last step before running your gnapplet is to create an HTML file that
will be loaded into your viewer or browser. This HTML file should include a
special tag that indicates where you want to run your applet, and what size
its allotted window should be. The <code>WIDTH</code> and <code>HEIGHT</code> parameters
below are mandatory.  The <code>ARCHIVE</code> parameter is only required when you
created a zip archive (as you did above with <code>jarmake</code>). As an example,
a minimal html file for the previous example could be:

<pre class="smallexample">         &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;/head&gt;
         &lt;body&gt;
           &lt;APPLET CODE="animate$typ.class"
            ARCHIVE="animate.jar"
            WIDTH=200 HEIGHT=200&gt; &lt;/APPLET&gt;
         &lt;/body&gt; &lt;/html&gt;
</pre>
   <div class="node">
<a name="Debugging-Ada-Programs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Limitations">Limitations</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Creating-Gnapplets-with-GNAT">Creating Gnapplets with GNAT</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="chapter">10 Debugging Ada Programs</h2>

<!-- =========================================================================== -->
<p class="noindent">Because GNAT generates class files that are fully compliant with Sun's JVM
standard, you can use any JVM debugger, such as Sun's <code>jdb</code>, with GNAT.

   <p>The minor drawback of using a JVM debugger directly is that for those Ada
constructs that are not directly available in the Java programming language
(e.g. attributes), you need to know how GNAT compiles these into bytecode in
order to retrieve their value.

   <p>The purpose of this chapter is precisely to explain how the GNAT compiler
compiles Ada contructs into bytecode so that you can use any Java debugger on
your Ada application.

   <p>Note that this chapter is not yet complete. If you need to understand what the
GNAT compiler generates for a particular Ada construct which is not documented
below, we suggest running the command <code>jvmlist -g</code> on the generated JVM
<samp><span class="file">.class</span></samp> files.

<ul class="menu">
<li><a accesskey="1" href="#Ada-Compilation-Units-and-JVM-Class-Files">Ada Compilation Units and JVM Class Files</a>
<li><a accesskey="2" href="#Lexical-Elements">Lexical Elements</a>
<li><a accesskey="3" href="#Enumeration-Types">Enumeration Types</a>
<li><a accesskey="4" href="#Integer-Types">Integer Types</a>
<li><a accesskey="5" href="#Floating-Point-Types">Floating Point Types</a>
</ul>

<div class="node">
<a name="Ada-Compilation-Units-and-JVM-Class-Files"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Lexical-Elements">Lexical Elements</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Debugging-Ada-Programs">Debugging Ada Programs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Debugging-Ada-Programs">Debugging Ada Programs</a>

</div>

<h3 class="section">10.1 Ada Compilation Units and JVM Class Files</h3>

<!--  -->
<p class="noindent">Unless pragma <code>Export</code> is used (see <a href="#Pragma-Export-Java">Pragma Export Java</a>), lower-case
letters are used for the names of all JVM class files generated from the
compilation of an Ada unit. Likewise, the names of all of the entities
generated inside a class file are lower-case.

   <p>The compilation of a nongeneric Ada library unit <var>P</var> always generates
a JVM class file (<samp><span class="file">p.class</span></samp>). In addition to the class file
<samp><span class="file">p.class</span></samp>, separate class files are emitted for each nested
exception, record type, and tagged type declared in unit <var>P</var>. 
More specifically:

     <ul>
<li>A subprogram library unit <code>P</code> is compiled into a JVM class file
<samp><span class="file">p.class</span></samp> containing all the objects and nondispatching operations
defined inside <code>P</code>.

     <li>The specification and body of a library package <code>P</code> are compiled
into a single JVM class file <samp><span class="file">p.class</span></samp> containing all of the objects
and nondispatching operations defined in the spec or body of <code>P</code>.

     <li>Any tagged or untagged record type <code>R</code> declared inside a package or
subprogram <code>P</code> is treated like a static inner class in Java, that is,
a new JVM class <samp><span class="file">p$r.class</span></samp> is generated containing <code>R</code>'s fields
as instance variables, and, if <code>R</code> is a tagged type, its associated
dispatching operations.

     <li>A package <code>Q</code> nested inside an Ada unit <code>P</code> does not result
in a separate class. Entities declared within the nested package
will generally be associated as members of the containing library
package's class (except in the case of exceptions or type declarations
that, as usual, result in their own class). However, the names of the
corresponding fields and methods resulting from the nested package will
be given expanded names that include the name of the outermost
library package followed by the names of any enclosing nested
packages, and where adjacent pairs of simple names in the expanded
are separated by dollar sign characters (e.g., <samp><span class="file">p$q$proc</span></samp>).

     <li>A child unit <code>P.Q</code> is compiled into the JVM class file
<samp><span class="file">p$q.class</span></samp>. All the rules described here are applied recursively with
respect to <code>Q</code>'s contents.

     <li>A generic package instantiation <code>R</code> nested inside an Ada unit <code>P</code> is
treated exactly like a nested package.

     <li>A generic subprogram instantiation <code>S</code> nested inside an Ada unit <code>P</code>
treated exacly like a nested subprogram.

     <li>An Ada exception <code>E</code> declared inside an Ada unit <code>P</code> is treated like
a member class in Java and is compiled into JVM class <samp><span class="file">p$e.class</span></samp>.

     <li>A task type or protected type <var>T</var> nested inside an Ada unit <code>P</code> is
compiled into JVM class file <samp><span class="file">p$t.class</span></samp>.

     <li>A subprogram <code>N</code> nested inside another subprogram <code>P</code> will
be treated as a static method of the enclosing library unit's class
and will be given an expanded name that includes the names of any
enclosing subprograms (e.g., <samp><span class="file">pkg$p$n</span></samp>). In addition, a special
class will be generated for the nested subprogram's enclosing
subprogram to contain fields for any objects of the enclosing subprogram
that are referenced by the nested subprogram. The name of this
special Activation Record class is constructed by appending the prefix
<samp><span class="file">__AR_</span></samp> to the name of the enclosing subprogram (e.g., <samp><span class="file">__AR_pkg$p</span></samp>).

     <li>Any other Ada type or construct <code>X</code> occurring inside an Ada unit <code>P</code>
that needs to generate a standalone JVM class will be compiled into
<samp><span class="file">p$x.class</span></samp>. 
</ul>

<p class="noindent">As an example, the compilation of the following package:

<pre class="smallexample">     package Outer is
        package Nested is
           type Typ is tagged record
              Field : Integer;
           end record;
     
           E : exception
        end Nested;
     
        type Rec is record
          X : Float;
        end record;
     end Outer;
</pre>
   <p class="noindent">yields the following JVM class files: <samp><span class="file">outer.class</span></samp>,
<samp><span class="file">outer$nested$typ.class</span></samp>, <br>
<samp><span class="file">outer$nested$e.class</span></samp>, <samp><span class="file">outer$rec.class</span></samp>.

<div class="node">
<a name="Lexical-Elements"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Enumeration-Types">Enumeration Types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ada-Compilation-Units-and-JVM-Class-Files">Ada Compilation Units and JVM Class Files</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Debugging-Ada-Programs">Debugging Ada Programs</a>

</div>

<h3 class="section">10.2 Lexical Elements</h3>

<!--  -->
<p class="noindent">All Ada identifiers are mapped into the corresponding lower case identifiers
when generating symbolic references for the JVM, unless <code>pragma Export</code> is
used (but note that certain names corresponding to internal entities generated
by the GNAT front end may inlude upper-case letters).

<div class="node">
<a name="Enumeration-Types"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Integer-Types">Integer Types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Lexical-Elements">Lexical Elements</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Debugging-Ada-Programs">Debugging Ada Programs</a>

</div>

<h3 class="section">10.3 Enumeration Types</h3>

<!--  -->
<p class="noindent">An Ada enumeration type is converted into a Java 1-byte, 2-byte, 4-byte or
8-byte integer whose size best matches the value of the largest enumeration
literal.

   <p>Character types are treated like regular Ada enumeration types. More
specifically, an Ada <code>Character</code> type is mapped into a Java <code>byte</code>,
whereas an Ada <code>Wide_Character</code> type is mapped onto the equivalent
2-byte Java <code>char</code> type.

   <p>An Ada boolean type is treated like a standard Ada enumeration type with 2
values and is consequently mapped into a Java <code>byte</code>.

<div class="node">
<a name="Integer-Types"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Floating-Point-Types">Floating Point Types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Enumeration-Types">Enumeration Types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Debugging-Ada-Programs">Debugging Ada Programs</a>

</div>

<h3 class="section">10.4 Integer Types</h3>

<!--  -->
<p class="noindent">Each signed integer type is mapped into the smallest corresponding JVM integer
type whose size is able to represent all required integer values:

<pre class="smallexample">           Short_Short_Integer  <i>is mapped into</i>  byte  <i>(1 byte)</i>
           Short_Integer        <i> "    "     " </i>  short <i>(2 bytes)</i>
           Integer              <i> "    "     " </i>  int   <i>(4 bytes)</i>
           Long_Integer         <i> "    "     " </i>  long  <i>(8 bytes)</i>
           Long_Long_Integer    <i> "    "     " </i>  long  <i>(8 bytes)</i>
</pre>
   <p class="noindent">Each modular type is also mapped into the smallest corresponding Java integer
type whose size is able to represent all required modular values.

<div class="node">
<a name="Floating-Point-Types"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Integer-Types">Integer Types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Debugging-Ada-Programs">Debugging Ada Programs</a>

</div>

<h3 class="section">10.5 Floating Point Types</h3>

<!--  -->
<p class="noindent">The Ada predefined floating point types map very naturally onto Java's
IEEE 32-bit float and IEEE 64-bit double:

<pre class="smallexample">           Short_Float     <i>is mapped into</i>  float  <i>(4 bytes)</i>
           Float           <i> "    "     " </i>  float  <i>(4 bytes)</i>
           Long_Float      <i> "    "     " </i>  double <i>(8 bytes)</i>
           Long_Long_Float <i> "    "     " </i>  double <i>(8 bytes)</i>
</pre>
   <p class="noindent">User-defined floating point types are mapped into <code>Float</code> where
possible, and <code>Long_Float</code> otherwise.

<div class="node">
<a name="Limitations"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Index">Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Debugging-Ada-Programs">Debugging Ada Programs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="chapter">11 Limitations</h2>

<!-- =========================================================================== -->
<p class="noindent">Due to constraints of the JVM environment, or to implementation limitations,
GNAT only supports a subset of the Ada language and GNAT run-time.

<p class="noindent">Language constructs not supported:

     <ul>
<li>Types imported from Java do not support enumeration attributes
(e.g. <code>'Image</code>)

     <li>Exception streams and attributes

     <li>Representation items  (13.1)

     <li>pragma <code>Pack</code> (ignored) (13.2)

     <li>Representation attributes (13.3)

     <li>Record layout   (13.5)

     <li>Machine Code Insertions  (13.8)

     <li><code>Unchecked_Conversion</code> between different non scalar types  (13.9)

     <li>Limited support on Ada.Streams package  (13.13)

     <li><code>'Size</code> attribute on non scalar objects

     <li><code>'Storage_Size</code> attribute on non-task objects

     <li><code>'First_Bit</code>, <code>'Last_Bit</code>, <code>'Position</code> attributes

     <li><code>'External_Tag</code> attribute

     <li><code>'Pred</code>, <code>'Succ</code> attribute for modular types

     <li><code>'Version</code> and <code>'Body_Version</code> attributes

     <li>Limited support of the <code>'Val</code> attribute

     <li>Function returning unconstrained array will have wrong <code>'First</code>
and <code>'Last</code>

     <li>User-defined Storage_Pools

     <li>Limited support for controlled types

     <li><code>'Address</code> on non-aliased, non-local objects

     <li><code>System.Address</code> comparisons, other than <code>"="</code> and
<code>"/="</code>

     <li>Some forms of scalar object renaming (e.g. renaming of dereferenced

     <p>access value)

     <li>Pragmas <code>Import</code>, <code>Export</code>, and <code>Convention</code> other than
<code>Ada</code> and <code>Java</code>

     <li>Pragma <code>Interrupt_Handler</code>, <code>Attach_Handler</code>

     <li>Asynchronous abort of tasking constructs and tasks

     <li>Access-to-protected-subprogram types

     <li>Incomplete types completed in package bodies

     <li><code>Wide_String</code> and <code>Wide_Wide_String</code> (e.g. ACATS test c250001)

     <li>Null arrays with multiple dimensions

   </ul>

<p class="noindent">Switches not supported:

     <ul>
<li>-gnatE (dynamic elaboration)
</ul>

<p class="noindent">Run-time units not supported:

     <ul>
<li>Ada.Sequential_IO.C_Streams, Ada.Storage_IO,
  Ada.Text_IO.C_Streams, Ada.Wide_Text_IO.C_Streams, Ada.Direct_IO.C_Streams
<li>Ada.Real_Time.Timing_Events

     <li>Ada.Asynchronous_Task_Control
<li>Ada.Command_Line.Environment
<li>Ada.Directories
<li>Ada.Exceptions.Traceback
<li>Ada.Interrupts,
<li>Ada.Task_Attributes,
<li>Ada.Task_Termination,

     <li>Interfaces.C.Extensions, Interfaces.Cobol, Interfaces.C.Pointers,
  Interfaces.CPP, Interfaces.C.Strings, Interfaces.Fortran,
  Interfaces.Packed_Decimal

     <li>Machine_Code, System.Machine_Code

     <li>GNAT.Altivec
<li>GNAT.Array_Split
<li>GNAT.Lock_Files, GNAT.Socket
<li>GNAT.Exceptions, GNAT.Expect, GNAT.AWK, GNAT.CGI, GNAT.CRC32, GNAT.MD5,
  GNAT.SHA1, GNAT.Spitbol
<li>GNAT.Byte_Swapping
<li>GNAT.Calendar
<li>GNAT.Command_Line
<li>GNAT.Compiler_Version
<li>GNAT.Current_Exception, GNAT.Debug_Pools, GNAT.Debug_Utilities,
  GNAT.Exception_Actions, GNAT.Exception_Traces, GNAT.Memory_Dump
<li>GNAT.Dynamic_Tables
<li>GNAT.Float_Control
<li>GNAT.IO
<li>GNAT.OS_Lib
<li>GNAT.Perfect_Hash_Generators
<li>GNAT.Secondary_Stack_Info
<li>GNAT.Table
<li>GNAT.Task_Stack_Usage
<li>GNAT.Time_Stamp
<li>GNAT.Thread, GNAT.Signal
<li>GNAT.String_Split, GNAT.Wide_String_Split, GNAT.Wide_Wide_String_Split
  GNAT.Traceback

   </ul>

<div class="node">
<a name="Index"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Limitations">Limitations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">Index</h2>

<ul class="index-cp" compact>
<li><a href="#index-g_t_0040code_007b_002dc_007d-_0028_0040code_007bjvm2ada_007d_0029-4"><code>-c</code> (<code>jvm2ada</code>)</a>: <a href="#Switches-for-jvmlist">Switches for jvmlist</a></li>
<li><a href="#index-g_t_0040code_007b_002dI_007d-_0028_0040code_007bjvm2ada_007d_0029-23"><code>-I</code> (<code>jvm2ada</code>)</a>: <a href="#Switches-for-jvm2ada">Switches for jvm2ada</a></li>
<li><a href="#index-g_t_0040code_007b_002dj_007d-_0028_0040code_007bjarmake_007d_0029-15"><code>-j</code> (<code>jarmake</code>)</a>: <a href="#Switches-for-jarmake">Switches for jarmake</a></li>
<li><a href="#index-g_t_0040code_007b_002dk_007d-_0028_0040code_007bjarmake_007d_0029-16"><code>-k</code> (<code>jarmake</code>)</a>: <a href="#Switches-for-jarmake">Switches for jarmake</a></li>
<li><a href="#index-g_t_0040code_007b_002dk_007d-_0028_0040code_007bjvm2ada_007d_0029-25"><code>-k</code> (<code>jvm2ada</code>)</a>: <a href="#Switches-for-jvm2ada">Switches for jvm2ada</a></li>
<li><a href="#index-g_t_0040code_007b_002dL_007d-_0028_0040code_007bjarmake_007d_0029-14"><code>-L</code> (<code>jarmake</code>)</a>: <a href="#Switches-for-jarmake">Switches for jarmake</a></li>
<li><a href="#index-g_t_0040code_007b_002dL_007d-_0028_0040code_007bjvm2ada_007d_0029-24"><code>-L</code> (<code>jvm2ada</code>)</a>: <a href="#Switches-for-jvm2ada">Switches for jvm2ada</a></li>
<li><a href="#index-g_t_0040code_007b_002dm_007d-_0028_0040code_007bjarmake_007d_0029-17"><code>-m</code> (<code>jarmake</code>)</a>: <a href="#Switches-for-jarmake">Switches for jarmake</a></li>
<li><a href="#index-g_t_0040code_007b_002dn_007d-_0028_0040code_007bjarmake_007d_0029-18"><code>-n</code> (<code>jarmake</code>)</a>: <a href="#Switches-for-jarmake">Switches for jarmake</a></li>
<li><a href="#index-g_t_0040code_007b_002do_007d-_0028_0040code_007bjarmake_007d_0029-19"><code>-o</code> (<code>jarmake</code>)</a>: <a href="#Switches-for-jarmake">Switches for jarmake</a></li>
<li><a href="#index-g_t_0040code_007b_002do_007d-_0028_0040code_007bjvm2ada_007d_0029-26"><code>-o</code> (<code>jvm2ada</code>)</a>: <a href="#Switches-for-jvm2ada">Switches for jvm2ada</a></li>
<li><a href="#index-g_t_0040code_007b_002dq_007d-_0028_0040code_007bjarmake_007d_0029-20"><code>-q</code> (<code>jarmake</code>)</a>: <a href="#Switches-for-jarmake">Switches for jarmake</a></li>
<li><a href="#index-g_t_0040code_007b_002dq_007d-_0028_0040code_007bjvm2ada_007d_0029-27"><code>-q</code> (<code>jvm2ada</code>)</a>: <a href="#Switches-for-jvm2ada">Switches for jvm2ada</a></li>
<li><a href="#index-g_t_0040code_007b_002dq_007d-_0028_0040code_007bjvm2ada_007d_0029-12"><code>-q</code> (<code>jvm2ada</code>)</a>: <a href="#Switches-for-jvmstrip">Switches for jvmstrip</a></li>
<li><a href="#index-g_t_0040code_007b_002dq_007d-_0028_0040code_007bjvm2ada_007d_0029-5"><code>-q</code> (<code>jvm2ada</code>)</a>: <a href="#Switches-for-jvmlist">Switches for jvmlist</a></li>
<li><a href="#index-g_t_0040code_007b_002ds_007d-_0028_0040code_007bjvm2ada_007d_0029-28"><code>-s</code> (<code>jvm2ada</code>)</a>: <a href="#Switches-for-jvm2ada">Switches for jvm2ada</a></li>
<li><a href="#index-g_t_0040code_007b_002dv_007d-_0028_0040code_007bjarmake_007d_0029-21"><code>-v</code> (<code>jarmake</code>)</a>: <a href="#Switches-for-jarmake">Switches for jarmake</a></li>
<li><a href="#index-g_t_0040code_007b_002dv_007d-_0028_0040code_007bjvm2ada_007d_0029-29"><code>-v</code> (<code>jvm2ada</code>)</a>: <a href="#Switches-for-jvm2ada">Switches for jvm2ada</a></li>
<li><a href="#index-g_t_0040code_007b_002dw_007d-_0028_0040code_007bjvm2ada_007d_0029-30"><code>-w</code> (<code>jvm2ada</code>)</a>: <a href="#Switches-for-jvm2ada">Switches for jvm2ada</a></li>
<li><a href="#index-Conventions-1">Conventions</a>: <a href="#Conventions">Conventions</a></li>
<li><a href="#index-jarmake-13">jarmake</a>: <a href="#Building-Archives-with-jarmake">Building Archives with jarmake</a></li>
<li><a href="#index-jvm2ada-22">jvm2ada</a>: <a href="#Using-the-Java-API-with-jvm2ada">Using the Java API with jvm2ada</a></li>
<li><a href="#index-jvmlist-3">jvmlist</a>: <a href="#Viewing-Class-Files-with-jvmlist">Viewing Class Files with jvmlist</a></li>
<li><a href="#index-jvmstrip-11">jvmstrip</a>: <a href="#Stripping-Debug-Info-with-jvmstrip">Stripping Debug Info with jvmstrip</a></li>
<li><a href="#index-Typographical-conventions-2">Typographical conventions</a>: <a href="#Conventions">Conventions</a></li>
</ul>
<div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_About-This-Guide" href="#About-This-Guide">About This Guide</a>
<ul>
<li><a href="#What-This-Guide-Contains">What This Guide Contains</a>
<li><a href="#What-you-should-know-before-reading-this-guide">What You Should Know Before Reading This Guide</a>
<li><a href="#Related-Information">Related Information</a>
<li><a href="#Conventions">Conventions</a>
</li></ul>
<li><a name="toc_Getting-Started-with-GNAT-for-the-JVM" href="#Getting-Started-with-GNAT-for-the-JVM">1 Getting Started with GNAT for the JVM</a>
<ul>
<li><a href="#Overview">1.1 Overview</a>
<li><a href="#GNAT-Tools">1.2 GNAT Tools</a>
<li><a href="#Java-Development-Kits-that-you-can-use-with-GNAT">1.3 Java Development Kits that you can use with GNAT</a>
<li><a href="#Compiling-Your-First-Application-with-GNAT-for-the-JVM">1.4 Compiling Your First Application with GNAT</a>
</li></ul>
<li><a name="toc_Ada-_0026-Java-Interoperability" href="#Ada-_0026-Java-Interoperability">2 Ada &amp; Java Interoperability</a>
<ul>
<li><a href="#Importing-Java-Services-to-Ada">2.1 Importing Java Services to Ada</a>
<li><a href="#Exporting-Ada-Services-to-Java">2.2 Exporting Ada Services to Java</a>
</li></ul>
<li><a name="toc_Viewing-Class-Files-with-jvmlist" href="#Viewing-Class-Files-with-jvmlist">3 Viewing Class Files with <code>jvmlist</code></a>
<ul>
<li><a href="#Running-jvmlist">3.1 Running jvmlist</a>
<li><a href="#Switches-for-jvmlist">3.2 Switches for jvmlist</a>
</li></ul>
<li><a name="toc_Stripping-Debug-Info-with-jvmstrip" href="#Stripping-Debug-Info-with-jvmstrip">4 Stripping Debug Info with <code>jvmstrip</code></a>
<ul>
<li><a href="#Running-jvmstrip">4.1 Running jvmstrip</a>
<li><a href="#Switches-for-jvmstrip">4.2 Switches for jvmstrip</a>
</li></ul>
<li><a name="toc_Building-Archives-with-jarmake" href="#Building-Archives-with-jarmake">5 Building Archives with <code>jarmake</code></a>
<ul>
<li><a href="#Running-jarmake">5.1 Running jarmake</a>
<li><a href="#Switches-for-jarmake">5.2 Switches for <code>jarmake</code></a>
</li></ul>
<li><a name="toc_Using-the-Java-API-with-jvm2ada" href="#Using-the-Java-API-with-jvm2ada">6 Using the Java API with <code>jvm2ada</code></a>
<ul>
<li><a href="#Running-jvm2ada">6.1 Running <code>jvm2ada</code></a>
<li><a href="#Switches-for-jvm2ada">6.2 Switches for <code>jvm2ada</code></a>
<li><a href="#Running-jvm2ada-on-the-Java-API">6.3 Running jvm2ada on the Java API</a>
<li><a href="#Parameter-Names-and-Source-Search-Paths">6.4 Parameter Names and Source Search Paths</a>
<li><a href="#Class-File-Search-Paths">6.5 Class File Search Paths</a>
<li><a href="#Identifier-Mangling">6.6 Identifier Mangling</a>
</li></ul>
<li><a name="toc_Java_002dSpecific-Pragmas" href="#Java_002dSpecific-Pragmas">7 Java-Specific Pragmas</a>
<ul>
<li><a href="#Creating-Java-Interfaces-with-Pragma-Java_005fInterface">7.1 Creating Java Interfaces: Pragma <code>Java_Interface</code></a>
<li><a href="#Using-Java-Interfaces">7.2 Using Java Interfaces</a>
<li><a href="#The-Java_005fConstructor-Pragma">7.3 The <code>Java_Constructor</code> Pragma</a>
<ul>
<li><a href="#Background-on-Java-Constructors">7.3.1 Background on Java Constructors</a>
<li><a href="#Using-Java-Constructors-in-Ada">7.3.2 Using Java Constructors in Ada</a>
<li><a href="#Java-Constructors-and-Ada-Allocators">7.3.3 Java Constructors and Ada Allocators</a>
</li></ul>
<li><a href="#Pragma-Import-Java">7.4 Pragma Import Java</a>
<ul>
<li><a href="#Importing-Packages">7.4.1 Importing Packages</a>
<li><a href="#Importing-Exceptions">7.4.2 Importing Exceptions</a>
<li><a href="#Importing-Record-Components">7.4.3 Importing Record Components</a>
<li><a href="#Importing-Dispatching-Subprograms">7.4.4 Importing Dispatching Subprograms</a>
<li><a href="#Importing-Objects">7.4.5 Importing Objects</a>
<li><a href="#Importing-Non_002dDispatching-Subprograms">7.4.6 Importing Non-Dispatching Subprograms</a>
</li></ul>
<li><a href="#Pragma-Export-Java">7.5 Pragma Export Java</a>
<ul>
<li><a href="#Exporting-Objects-Subprograms-and-Record-Components">7.5.1 Exporting Objects, Subprograms, and Record Components</a>
<li><a href="#Exporting-Exceptions">7.5.2 Exporting Exceptions</a>
<li><a href="#Exporting-Packages-or-Record-Types">7.5.3 Exporting Packages or Record Types</a>
</li></ul>
</li></ul>
<li><a name="toc_Mapping-Java-into-Ada" href="#Mapping-Java-into-Ada">8 Mapping Java into Ada</a>
<ul>
<li><a href="#Identifiers">8.1 Identifiers</a>
<li><a href="#Scalar-Types">8.2 Scalar Types</a>
<li><a href="#Java-References-and-java_002elang_002eObject">8.3 Java References and <code>java.lang.Object</code></a>
<li><a href="#Array-Types">8.4 Array Types</a>
<li><a href="#The-Ada-Package-Java">8.5 The Ada Package <code>Java</code></a>
<li><a href="#Use-of-Limited_002dWith-Clauses-by-jvm2ada">8.6 Use of Limited-With Clauses by <code>jvm2ada</code></a>
<li><a href="#Java-Packages">8.7 Java Packages</a>
<li><a href="#Java-Classes">8.8 Java Classes</a>
<li><a href="#Abstract-Classes">8.9 Abstract Classes</a>
<li><a href="#Nested-Classes">8.10 Nested Classes</a>
<li><a href="#Java-Interface">8.11 Java Interface</a>
<li><a href="#Java-Class-Implementing-Interfaces">8.12 Java Class Implementing Interfaces</a>
<li><a href="#Java-Exceptions">8.13 Java Exceptions</a>
<li><a href="#Static-Fields">8.14 Static Fields</a>
<li><a href="#Final-Static-Fields">8.15 Final Static Fields</a>
<li><a href="#Instance-Fields">8.16 Instance Fields</a>
<li><a href="#Volatile-and-Transient-Fields">8.17 Volatile and Transient Fields</a>
<li><a href="#Static-Methods">8.18 Static Methods</a>
<li><a href="#Instance-Methods">8.19 Instance Methods</a>
<li><a href="#Abstract-Methods">8.20 Abstract Methods</a>
<li><a href="#Native-Methods">8.21 Native Methods</a>
<li><a href="#Final-Classes-and-Final-Methods">8.22 Final Classes and Final Methods</a>
<li><a href="#Visibility-Issues">8.23 Visibility Issues</a>
<li><a href="#Java-Implicit-Upcasting-in-Ada">8.24 Java Implicit Upcasting in Ada</a>
<li><a href="#Mixing-Ada-Strings-and-Java-Strings">8.25 Mixing Ada Strings and Java Strings</a>
<li><a href="#An-Example">8.26 An Example</a>
</li></ul>
<li><a name="toc_Creating-Gnapplets-with-GNAT" href="#Creating-Gnapplets-with-GNAT">9 Creating Gnapplets with GNAT</a>
<ul>
<li><a href="#Extending-java_002eapplet_002eApplet_002eTyp">9.1 Extending <code>java.applet.Applet.Typ</code></a>
<li><a href="#Initializing-and-Finalizing-the-GNAT-Runtime">9.2 Initializing and Finalizing the GNAT Runtime</a>
<li><a href="#Compiling-the-Gnapplet">9.3 Compiling the Gnapplet</a>
<li><a href="#Creating-the-HTML-file">9.4 Creating the HTML file</a>
</li></ul>
<li><a name="toc_Debugging-Ada-Programs" href="#Debugging-Ada-Programs">10 Debugging Ada Programs</a>
<ul>
<li><a href="#Ada-Compilation-Units-and-JVM-Class-Files">10.1 Ada Compilation Units and JVM Class Files</a>
<li><a href="#Lexical-Elements">10.2 Lexical Elements</a>
<li><a href="#Enumeration-Types">10.3 Enumeration Types</a>
<li><a href="#Integer-Types">10.4 Integer Types</a>
<li><a href="#Floating-Point-Types">10.5 Floating Point Types</a>
</li></ul>
<li><a name="toc_Limitations" href="#Limitations">11 Limitations</a>
<li><a name="toc_Index" href="#Index">Index</a>
</li></ul>
</div>

</body></html>

